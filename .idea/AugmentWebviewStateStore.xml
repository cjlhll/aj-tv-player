<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AugmentWebviewStateStore">
    <option name="stateMap">
      <map>
        <entry key="CHAT_STATE" value="{&quot;currentConversationId&quot;:&quot;6fbb0800-32b5-4380-88bf-eccc6417b403&quot;,&quot;conversations&quot;:{&quot;6fbb0800-32b5-4380-88bf-eccc6417b403&quot;:{&quot;id&quot;:&quot;6fbb0800-32b5-4380-88bf-eccc6417b403&quot;,&quot;createdAtIso&quot;:&quot;2025-08-22T06:52:05.429Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-08-22T06:54:18.385Z&quot;,&quot;chatHistory&quot;:[{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;797a6496-b869-4533-83fd-ae3087d1be9c&quot;,&quot;request_message&quot;:&quot;Please analyze the file `app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt` for any compilation errors, runtime issues, or logical bugs. Fix any identified problems in the code. After making the necessary corrections, build and run the Android TV player project on a Television device or emulator to verify that the fixes work correctly and the application functions as expected.\n\nSpecifically:\n1. First examine the SubtitleCache.kt file to identify any errors (syntax errors, type mismatches, missing imports, etc.)\n2. Fix any identified issues in the code\n3. Ensure the project compiles successfully\n4. Deploy and run the application on an Android TV device or TV emulator\n5. Verify that the subtitle caching functionality works properly without errors\n\nPlease provide details about what errors were found and how they were resolved.\n\n\n\n&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Please analyze the file `app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt` for any compilation errors, runtime issues, or logical bugs. Fix any identified problems in the code. After making the necessary corrections, build and run the Android TV player project on a Television device or emulator to verify that the fixes work correctly and the application functions as expected.&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Specifically:&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;1. First examine the SubtitleCache.kt file to identify any errors (syntax errors, type mismatches, missing imports, etc.)&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;2. Fix any identified issues in the code&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;3. Ensure the project compiles successfully&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;4. Deploy and run the application on an Android TV device or TV emulator&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;5. Verify that the subtitle caching functionality works properly without errors&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;hardBreak&quot;},{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Please provide details about what errors were found and how they were resolved.&quot;}]},{&quot;type&quot;:&quot;file&quot;,&quot;attrs&quot;:{&quot;src&quot;:&quot;3fff33cabb3b2d76580471326558d8bb2367b99346c8532d4f99b3ba490a3afa.png&quot;,&quot;alt&quot;:null,&quot;title&quot;:&quot;image.png&quot;,&quot;renderMode&quot;:&quot;collapsed&quot;,&quot;isLoading&quot;:false,&quot;fileSizeBytes&quot;:21222,&quot;mimeType&quot;:&quot;image/png&quot;}},{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01ELnoWc6SPsCEHCDDduVALs&quot;,&quot;tool_name&quot;:&quot;view&quot;,&quot;input_json&quot;:&quot;{\&quot;type\&quot;: \&quot;file\&quot;, \&quot;path\&quot;: \&quot;app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;I'll analyze the SubtitleCache.kt file to identify and fix the compilation errors. Let me start by examining the file to understand the issues.\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;Please analyze the file `app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt` for any compilation errors, runtime issues, or logical bugs. Fix any identified problems in the code. After making the necessary corrections, build and run the Android TV player project on a Television device or emulator to verify that the fixes work correctly and the application functions as expected.\n\nSpecifically:\n1. First examine the SubtitleCache.kt file to identify any errors (syntax errors, type mismatches, missing imports, etc.)\n2. Fix any identified issues in the code\n3. Ensure the project compiles successfully\n4. Deploy and run the application on an Android TV device or TV emulator\n5. Verify that the subtitle caching functionality works properly without errors\n\nPlease provide details about what errors were found and how they were resolved.&quot;}},{&quot;id&quot;:1,&quot;type&quot;:3,&quot;image_id_node&quot;:{&quot;image_id&quot;:&quot;3fff33cabb3b2d76580471326558d8bb2367b99346c8532d4f99b3ba490a3afa.png&quot;,&quot;format&quot;:1}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;E:/1-test/android-tv-player&quot;,&quot;folderRoot&quot;:&quot;E:/1-test/android-tv-player&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-22T06:54:02.425Z&quot;,&quot;response_text&quot;:&quot;I'll analyze the SubtitleCache.kt file to identify and fix the compilation errors. Let me start by examining the file to understand the issues.\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;36a183d7-5d28-405d-9c83-f536175a7a4a&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01SDHvcjHgyMiRnhZ1farxFU&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Find the Subtitle data class or model in the project, specifically looking for the structure of the Subtitle class including its properties like id, title, language, languageName, rating, uploadDate, isDownloaded, localPath, and any methods like isAvailable()\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me examine the Subtitle model class to understand its structure and identify any missing methods or properties that might be causing the compilation errors:\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt:\n     1\tpackage com.tvplayer.webdav.data.storage\n     2\t\n     3\timport android.content.Context\n     4\timport android.content.SharedPreferences\n     5\timport android.util.Log\n     6\timport com.google.gson.Gson\n     7\timport com.google.gson.reflect.TypeToken\n     8\timport com.tvplayer.webdav.data.model.Subtitle\n     9\timport dagger.hilt.android.qualifiers.ApplicationContext\n    10\timport kotlinx.coroutines.Dispatchers\n    11\timport kotlinx.coroutines.sync.Mutex\n    12\timport kotlinx.coroutines.sync.withLock\n    13\timport kotlinx.coroutines.withContext\n    14\timport java.io.File\n    15\timport java.util.concurrent.ConcurrentHashMap\n    16\timport javax.inject.Inject\n    17\timport javax.inject.Singleton\n    18\t\n    19\t/**\n    20\t * 字幕缓存管理器\n    21\t * 负责字幕信息的本地存储、检索和清理\n    22\t */\n    23\t@Singleton\n    24\tclass SubtitleCache @Inject constructor(\n    25\t    @ApplicationContext private val context: Context,\n    26\t    private val gson: Gson\n    27\t) {\n    28\t    \n    29\t    companion object {\n    30\t        private const val TAG = \&quot;SubtitleCache\&quot;\n    31\t        private const val PREFS_NAME = \&quot;subtitle_cache\&quot;\n    32\t        private const val KEY_SUBTITLES = \&quot;cached_subtitles\&quot;\n    33\t        private const val KEY_MEDIA_MAPPING = \&quot;media_subtitle_mapping\&quot;\n    34\t        private const val KEY_LAST_CLEANUP = \&quot;last_cleanup\&quot;\n    35\t        private const val SUBTITLE_DIR = \&quot;subtitles\&quot;\n    36\t        private const val MAX_CACHE_SIZE = 100 * 1024 * 1024L // 100MB\n    37\t        private const val CLEANUP_INTERVAL_DAYS = 7\n    38\t    }\n    39\t    \n    40\t    private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\n    41\t    private val cacheMutex = Mutex()\n    42\t    \n    43\t    // 内存缓存\n    44\t    private val subtitleMemoryCache = ConcurrentHashMap&lt;String, Subtitle&gt;()\n    45\t    private val mediaMappingCache = ConcurrentHashMap&lt;String, MutableSet&lt;String&gt;&gt;()\n    46\t    \n    47\t    private val subtitleDir: File by lazy {\n    48\t        File(context.cacheDir, SUBTITLE_DIR).apply {\n    49\t            if (!exists()) mkdirs()\n    50\t        }\n    51\t    }\n    52\t    \n    53\t    init {\n    54\t        // 启动时加载缓存\n    55\t        loadCacheFromPreferences()\n    56\t        \n    57\t        // 检查是否需要清理\n    58\t        checkAndCleanupIfNeeded()\n    59\t    }\n    60\t    \n    61\t    /**\n    62\t     * 保存字幕到缓存\n    63\t     * @param subtitle 字幕信息\n    64\t     * @param mediaId 关联的媒体ID（可选）\n    65\t     */\n    66\t    suspend fun saveSubtitle(subtitle: Subtitle, mediaId: String? = null) {\n    67\t        withContext(Dispatchers.IO) {\n    68\t            cacheMutex.withLock {\n    69\t                try {\n    70\t                    // 保存到内存缓存\n    71\t                    subtitleMemoryCache[subtitle.id] = subtitle\n    72\t                    \n    73\t                    // 如果有关联媒体，建立映射关系\n    74\t                    mediaId?.let { id -&gt;\n    75\t                        val subtitleIds = mediaMappingCache.getOrPut(id) { mutableSetOf() }\n    76\t                        subtitleIds.add(subtitle.id)\n    77\t                    }\n    78\t                    \n    79\t                    // 持久化到SharedPreferences\n    80\t                    persistCacheToPreferences()\n    81\t                    \n    82\t                    Log.d(TAG, \&quot;Subtitle cached: ${subtitle.id} for media: $mediaId\&quot;)\n    83\t                    \n    84\t                } catch (e: Exception) {\n    85\t                    Log.e(TAG, \&quot;Error saving subtitle to cache\&quot;, e)\n    86\t                }\n    87\t            }\n    88\t        }\n    89\t    }\n    90\t    \n    91\t    /**\n    92\t     * 获取媒体相关的字幕\n    93\t     * @param mediaId 媒体ID\n    94\t     * @return 字幕列表\n    95\t     */\n    96\t    fun getSubtitles(mediaId: String): List&lt;Subtitle&gt; {\n    97\t        return try {\n    98\t            val subtitleIds = mediaMappingCache[mediaId] ?: return emptyList()\n    99\t            subtitleIds.mapNotNull { subtitleMemoryCache[it] }\n   100\t                .filter { it.isAvailable() } // 只返回可用的字幕\n   101\t        } catch (e: Exception) {\n   102\t            Log.e(TAG, \&quot;Error getting subtitles for media: $mediaId\&quot;, e)\n   103\t            emptyList()\n   104\t        }\n   105\t    }\n   106\t    \n   107\t    /**\n   108\t     * 根据ID获取字幕\n   109\t     * @param subtitleId 字幕ID\n   110\t     * @return 字幕信息，如果不存在返回null\n   111\t     */\n   112\t    fun getSubtitle(subtitleId: String): Subtitle? {\n   113\t        return subtitleMemoryCache[subtitleId]\n   114\t    }\n   115\t    \n   116\t    /**\n   117\t     * 搜索字幕\n   118\t     * @param query 搜索关键词\n   119\t     * @param language 语言过滤（可选）\n   120\t     * @return 匹配的字幕列表\n   121\t     */\n   122\t    fun searchSubtitles(query: String, language: String? = null): List&lt;Subtitle&gt; {\n   123\t        return try {\n   124\t            val lowerQuery = query.lowercase()\n   125\t            subtitleMemoryCache.values.filter { subtitle -&gt;\n   126\t                val matchesQuery = subtitle.title.lowercase().contains(lowerQuery) ||\n   127\t                                 subtitle.languageName.lowercase().contains(lowerQuery)\n   128\t                \n   129\t                val matchesLanguage = language?.let { lang -&gt;\n   130\t                    subtitle.language.equals(lang, ignoreCase = true) ||\n   131\t                    subtitle.language.startsWith(lang, ignoreCase = true)\n   132\t                } ?: true\n   133\t                \n   134\t                matchesQuery &amp;&amp; matchesLanguage &amp;&amp; subtitle.isAvailable()\n   135\t            }.sortedByDescending { it.rating }\n   136\t        } catch (e: Exception) {\n   137\t            Log.e(TAG, \&quot;Error searching subtitles\&quot;, e)\n   138\t            emptyList()\n   139\t        }\n   140\t    }\n   141\t    \n   142\t    /**\n   143\t     * 删除字幕\n   144\t     * @param subtitleId 字幕ID\n   145\t     */\n   146\t    suspend fun removeSubtitle(subtitleId: String) {\n   147\t        withContext(Dispatchers.IO) {\n   148\t            cacheMutex.withLock {\n   149\t                try {\n   150\t                    val subtitle = subtitleMemoryCache[subtitleId]\n   151\t                    \n   152\t                    // 删除本地文件\n   153\t                    subtitle?.let { sub -&gt;\n   154\t                        if (sub.isDownloaded &amp;&amp; sub.localPath.isNotEmpty()) {\n   155\t                            val file = File(sub.localPath)\n   156\t                            if (file.exists() &amp;&amp; file.delete()) {\n   157\t                                Log.d(TAG, \&quot;Deleted subtitle file: ${sub.localPath}\&quot;)\n   158\t                            }\n   159\t                        }\n   160\t                    }\n   161\t                    \n   162\t                    // 从内存缓存移除\n   163\t                    subtitleMemoryCache.remove(subtitleId)\n   164\t                    \n   165\t                    // 从媒体映射中移除\n   166\t                    mediaMappingCache.values.forEach { subtitleIds -&gt;\n   167\t                        subtitleIds.remove(subtitleId)\n   168\t                    }\n   169\t                    \n   170\t                    // 持久化更改\n   171\t                    persistCacheToPreferences()\n   172\t                    \n   173\t                    Log.d(TAG, \&quot;Subtitle removed from cache: $subtitleId\&quot;)\n   174\t                    \n   175\t                } catch (e: Exception) {\n   176\t                    Log.e(TAG, \&quot;Error removing subtitle from cache\&quot;, e)\n   177\t                }\n   178\t            }\n   179\t        }\n   180\t    }\n   181\t    \n   182\t    /**\n   183\t     * 清理过期字幕\n   184\t     * @param expireDays 过期天数\n   185\t     */\n   186\t    suspend fun cleanExpiredSubtitles(expireDays: Int = 30) {\n   187\t        withContext(Dispatchers.IO) {\n   188\t            cacheMutex.withLock {\n   189\t                try {\n   190\t                    val expireTime = System.currentTimeMillis() - (expireDays * 24 * 60 * 60 * 1000L)\n   191\t                    val expiredSubtitleIds = mutableListOf&lt;String&gt;()\n   192\t                    \n   193\t                    subtitleMemoryCache.values.forEach { subtitle -&gt;\n   194\t                        if (subtitle.uploadDate &gt; 0 &amp;&amp; subtitle.uploadDate &lt; expireTime) {\n   195\t                            expiredSubtitleIds.add(subtitle.id)\n   196\t                        }\n   197\t                    }\n   198\t                    \n   199\t                    // 删除过期字幕\n   200\t                    for (subtitleId in expiredSubtitleIds) {\n   201\t                        try {\n   202\t                            val subtitle = subtitleMemoryCache[subtitleId]\n   203\t                            \n   204\t                            // 删除本地文件\n   205\t                            subtitle?.let { sub -&gt;\n   206\t                                if (sub.isDownloaded &amp;&amp; sub.localPath.isNotEmpty()) {\n   207\t                                    val file = File(sub.localPath)\n   208\t                                    if (file.exists() &amp;&amp; file.delete()) {\n   209\t                                        Log.d(TAG, \&quot;Deleted subtitle file: ${sub.localPath}\&quot;)\n   210\t                                    }\n   211\t                                }\n   212\t                            }\n   213\t                            \n   214\t                            // 从内存缓存移除\n   215\t                            subtitleMemoryCache.remove(subtitleId)\n   216\t                            \n   217\t                            // 从媒体映射中移除\n   218\t                            mediaMappingCache.values.forEach { subtitleIds -&gt;\n   219\t                                subtitleIds.remove(subtitleId)\n   220\t                            }\n   221\t                        } catch (e: Exception) {\n   222\t                            Log.e(TAG, \&quot;Error removing expired subtitle: $subtitleId\&quot;, e)\n   223\t                        }\n   224\t                    }\n   225\t                    \n   226\t                    // 持久化更改\n   227\t                    persistCacheToPreferences()\n   228\t                    \n   229\t                    // 清理孤立的字幕文件\n   230\t                    cleanOrphanedFiles()\n   231\t                    \n   232\t                    // 更新最后清理时间\n   233\t                    preferences.edit()\n   234\t                        .putLong(KEY_LAST_CLEANUP, System.currentTimeMillis())\n   235\t                        .apply()\n   236\t                    \n   237\t                    Log.d(TAG, \&quot;Cleaned ${expiredSubtitleIds.size} expired subtitles\&quot;)\n   238\t                    \n   239\t                } catch (e: Exception) {\n   240\t                    Log.e(TAG, \&quot;Error cleaning expired subtitles\&quot;, e)\n   241\t                }\n   242\t            }\n   243\t        }\n   244\t    }\n   245\t    \n   246\t    /**\n   247\t     * 清理缓存以释放空间\n   248\t     * @param targetSize 目标大小（字节）\n   249\t     */\n   250\t    suspend fun cleanupToSize(targetSize: Long = MAX_CACHE_SIZE) {\n   251\t        withContext(Dispatchers.IO) {\n   252\t            cacheMutex.withLock {\n   253\t                try {\n   254\t                    val currentSize = getCacheSize()\n   255\t                    if (currentSize &lt;= targetSize) {\n   256\t                        return@withLock\n   257\t                    }\n   258\t                    \n   259\t                    Log.d(TAG, \&quot;Cache size: $currentSize bytes, target: $targetSize bytes\&quot;)\n   260\t                    \n   261\t                    // 按最后访问时间排序，删除最老的文件\n   262\t                    val subtitleFiles = subtitleDir.listFiles()?.sortedBy { it.lastModified() } ?: return@withLock\n   263\t                    var freedSize = 0L\n   264\t                    \n   265\t                    for (file in subtitleFiles) {\n   266\t                        if (currentSize - freedSize &lt;= targetSize) {\n   267\t                            break\n   268\t                        }\n   269\t                        \n   270\t                        val fileSize = file.length()\n   271\t                        if (file.delete()) {\n   272\t                            freedSize += fileSize\n   273\t                            \n   274\t                            // 从缓存中移除对应的字幕记录（非异步方式）\n   275\t                            val subtitleToRemove = subtitleMemoryCache.values.find { \n   276\t                                it.localPath == file.absolutePath \n   277\t                            }\n   278\t                            subtitleToRemove?.let { subtitle -&gt;\n   279\t                                // 直接从内存缓存移除，避免suspend函数调用\n   280\t                                subtitleMemoryCache.remove(subtitle.id)\n   281\t                                \n   282\t                                // 从媒体映射中移除\n   283\t                                mediaMappingCache.values.forEach { subtitleIds -&gt;\n   284\t                                    subtitleIds.remove(subtitle.id)\n   285\t                                }\n   286\t                            }\n   287\t                        }\n   288\t                    }\n   289\t                    \n   290\t                    Log.d(TAG, \&quot;Freed $freedSize bytes from cache\&quot;)\n   291\t                    \n   292\t                } catch (e: Exception) {\n   293\t                    Log.e(TAG, \&quot;Error cleaning up cache\&quot;, e)\n   294\t                }\n   295\t            }\n   296\t        }\n   297\t    }\n   298\t    \n   299\t    /**\n   300\t     * 获取缓存统计信息\n   301\t     */\n   302\t    fun getCacheStats(): CacheStats {\n   303\t        return try {\n   304\t            val totalSubtitles = subtitleMemoryCache.size\n   305\t            val downloadedSubtitles = subtitleMemoryCache.values.count { it.isDownloaded }\n   306\t            val cacheSize = getCacheSize()\n   307\t            val lastCleanup = preferences.getLong(KEY_LAST_CLEANUP, 0L)\n   308\t            \n   309\t            CacheStats(\n   310\t                totalSubtitles = totalSubtitles,\n   311\t                downloadedSubtitles = downloadedSubtitles,\n   312\t                cacheSize = cacheSize,\n   313\t                lastCleanup = lastCleanup\n   314\t            )\n   315\t        } catch (e: Exception) {\n   316\t            Log.e(TAG, \&quot;Error getting cache stats\&quot;, e)\n   317\t            CacheStats()\n   318\t        }\n   319\t    }\n   320\t    \n   321\t    /**\n   322\t     * 清空所有缓存\n   323\t     */\n   324\t    suspend fun clearAllCache() {\n   325\t        withContext(Dispatchers.IO) {\n   326\t            cacheMutex.withLock {\n   327\t                try {\n   328\t                    // 删除所有字幕文件\n   329\t                    subtitleDir.listFiles()?.forEach { file -&gt;\n   330\t                        file.delete()\n   331\t                    }\n   332\t                    \n   333\t                    // 清空内存缓存\n   334\t                    subtitleMemoryCache.clear()\n   335\t                    mediaMappingCache.clear()\n   336\t                    \n   337\t                    // 清空持久化数据\n   338\t                    preferences.edit().clear().apply()\n   339\t                    \n   340\t                    Log.d(TAG, \&quot;All cache cleared\&quot;)\n   341\t                    \n   342\t                } catch (e: Exception) {\n   343\t                    Log.e(TAG, \&quot;Error clearing cache\&quot;, e)\n   344\t                }\n   345\t            }\n   346\t        }\n   347\t    }\n   348\t    \n   349\t    // 私有辅助方法\n   350\t    \n   351\t    private fun loadCacheFromPreferences() {\n   352\t        try {\n   353\t            // 加载字幕数据\n   354\t            val subtitlesJson = preferences.getString(KEY_SUBTITLES, \&quot;\&quot;)\n   355\t            if (!subtitlesJson.isNullOrEmpty()) {\n   356\t                val type = object : TypeToken&lt;Map&lt;String, Subtitle&gt;&gt;() {}.type\n   357\t                val subtitles: Map&lt;String, Subtitle&gt; = gson.fromJson(subtitlesJson, type)\n   358\t                subtitleMemoryCache.putAll(subtitles)\n   359\t            }\n   360\t            \n   361\t            // 加载媒体映射\n   362\t            val mappingJson = preferences.getString(KEY_MEDIA_MAPPING, \&quot;\&quot;)\n   363\t            if (!mappingJson.isNullOrEmpty()) {\n   364\t                val type = object : TypeToken&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt;() {}.type\n   365\t                val mapping: Map&lt;String, Set&lt;String&gt;&gt; = gson.fromJson(mappingJson, type)\n   366\t                mapping.forEach { (mediaId, subtitleIds) -&gt;\n   367\t                    mediaMappingCache[mediaId] = subtitleIds.toMutableSet()\n   368\t                }\n   369\t            }\n   370\t            \n   371\t            Log.d(TAG, \&quot;Loaded ${subtitleMemoryCache.size} subtitles from cache\&quot;)\n   372\t            \n   373\t        } catch (e: Exception) {\n   374\t            Log.e(TAG, \&quot;Error loading cache from preferences\&quot;, e)\n   375\t        }\n   376\t    }\n   377\t    \n   378\t    private fun persistCacheToPreferences() {\n   379\t        try {\n   380\t            val editor = preferences.edit()\n   381\t            \n   382\t            // 保存字幕数据\n   383\t            val subtitlesJson = gson.toJson(subtitleMemoryCache)\n   384\t            editor.putString(KEY_SUBTITLES, subtitlesJson)\n   385\t            \n   386\t            // 保存媒体映射\n   387\t            val mappingJson = gson.toJson(mediaMappingCache)\n   388\t            editor.putString(KEY_MEDIA_MAPPING, mappingJson)\n   389\t            \n   390\t            editor.apply()\n   391\t            \n   392\t        } catch (e: Exception) {\n   393\t            Log.e(TAG, \&quot;Error persisting cache to preferences\&quot;, e)\n   394\t        }\n   395\t    }\n   396\t    \n   397\t    private fun getCacheSize(): Long {\n   398\t        return try {\n   399\t            subtitleDir.listFiles()?.sumOf { it.length() } ?: 0L\n   400\t        } catch (e: Exception) {\n   401\t            0L\n   402\t        }\n   403\t    }\n   404\t    \n   405\t    private fun cleanOrphanedFiles() {\n   406\t        try {\n   407\t            val cachedPaths = subtitleMemoryCache.values\n   408\t                .mapNotNull { it.localPath.takeIf { path -&gt; path.isNotEmpty() } }\n   409\t                .toSet()\n   410\t            \n   411\t            subtitleDir.listFiles()?.forEach { file -&gt;\n   412\t                if (file.absolutePath !in cachedPaths) {\n   413\t                    if (file.delete()) {\n   414\t                        Log.d(TAG, \&quot;Deleted orphaned file: ${file.name}\&quot;)\n   415\t                    }\n   416\t                }\n   417\t            }\n   418\t        } catch (e: Exception) {\n   419\t            Log.w(TAG, \&quot;Error cleaning orphaned files: ${e.message}\&quot;)\n   420\t        }\n   421\t    }\n   422\t    \n   423\t    private fun checkAndCleanupIfNeeded() {\n   424\t        try {\n   425\t            val lastCleanup = preferences.getLong(KEY_LAST_CLEANUP, 0L)\n   426\t            val daysSinceCleanup = (System.currentTimeMillis() - lastCleanup) / (24 * 60 * 60 * 1000L)\n   427\t            \n   428\t            if (daysSinceCleanup &gt;= CLEANUP_INTERVAL_DAYS) {\n   429\t                // 异步执行清理，但不等待结果以避免suspend函数调用错误\n   430\t                kotlinx.coroutines.GlobalScope.launch {\n   431\t                    try {\n   432\t                        cleanExpiredSubtitles()\n   433\t                        cleanupToSize()\n   434\t                    } catch (e: Exception) {\n   435\t                        Log.w(TAG, \&quot;Error during background cleanup: ${e.message}\&quot;)\n   436\t                    }\n   437\t                }\n   438\t            }\n   439\t        } catch (e: Exception) {\n   440\t            Log.w(TAG, \&quot;Error checking cleanup: ${e.message}\&quot;)\n   441\t        }\n   442\t    }\n   443\t}\n   444\t\n   445\t/**\n   446\t * 缓存统计信息\n   447\t */\n   448\tdata class CacheStats(\n   449\t    val totalSubtitles: Int = 0,\n   450\t    val downloadedSubtitles: Int = 0,\n   451\t    val cacheSize: Long = 0L,\n   452\t    val lastCleanup: Long = 0L\n   453\t) {\n   454\t    val cacheSizeMB: Float\n   455\t        get() = cacheSize / (1024f * 1024f)\n   456\t        \n   457\t    val daysSinceCleanup: Long\n   458\t        get() = if (lastCleanup &gt; 0) {\n   459\t            (System.currentTimeMillis() - lastCleanup) / (24 * 60 * 60 * 1000L)\n   460\t        } else {\n   461\t            -1L\n   462\t        }\n   463\t}\nTotal lines in file: 463\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01ELnoWc6SPsCEHCDDduVALs&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;E:/1-test/android-tv-player&quot;,&quot;folderRoot&quot;:&quot;E:/1-test/android-tv-player&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-22T06:54:07.443Z&quot;,&quot;response_text&quot;:&quot;Now let me examine the Subtitle model class to understand its structure and identify any missing methods or properties that might be causing the compilation errors:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;4a53ac06-4696-42e8-aa07-db2c73e3cc41&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01PK6WyMNPrM4j5VYRPk3sKh&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Find any missing imports or dependencies related to coroutines, specifically looking for CoroutineScope, launch, and any application-level scope that should be used instead of GlobalScope\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:2,&quot;type&quot;:0,&quot;content&quot;:&quot;Now I can see the issues. Looking at the compilation errors and the code, I can identify the problems:\n\n1. **Line 430**: The code is using `kotlinx.coroutines.GlobalScope.launch` which is deprecated and should be avoided. This is causing a compilation error.\n2. **Lines 432-433**: The suspend functions `cleanExpiredSubtitles()` and `cleanupToSize()` are being called from a non-suspend context (inside `init` block).\n\nLet me check if there are any other issues by looking at the imports and dependencies:\n&quot;},{&quot;id&quot;:3,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:4,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;The following code sections were retrieved:\nPath: app/src/main/java/com/tvplayer/webdav/data/model/Subtitle.kt\n     1\tpackage com.tvplayer.webdav.data.model\n     2\t\n     3\timport android.os.Parcelable\n     4\timport kotlinx.parcelize.Parcelize\n     5\timport java.io.File\n     6\t\n     7\t/**\n     8\t * 字幕文件数据模型\n     9\t */\n    10\t@Parcelize\n    11\tdata class Subtitle(\n    12\t    val id: String = \&quot;\&quot;, // 字幕唯一标识\n    13\t    val title: String = \&quot;\&quot;, // 字幕标题\n    14\t    val language: String = \&quot;\&quot;, // 语言代码 (zh, en, zh-cn, en-us)\n    15\t    val languageName: String = \&quot;\&quot;, // 语言显示名称\n    16\t    val format: SubtitleFormat = SubtitleFormat.SRT, // 字幕格式\n    17\t    val encoding: String = \&quot;UTF-8\&quot;, // 字幕编码\n    18\t    val downloadUrl: String = \&quot;\&quot;, // 下载链接\n    19\t    val localPath: String = \&quot;\&quot;, // 本地文件路径\n    20\t    val fileSize: Long = 0L, // 文件大小（字节）\n    21\t    val hash: String = \&quot;\&quot;, // 文件哈希值\n    22\t    val source: SubtitleSource = SubtitleSource.UNKNOWN, // 字幕来源\n    23\t    val rating: Float = 0.0f, // 评分 (0.0-10.0)\n    24\t    val downloadCount: Int = 0, // 下载次数\n    25\t    val uploadDate: Long = 0L, // 上传时间戳\n    26\t    val uploader: String = \&quot;\&quot;, // 上传者\n    27\t    val isDownloaded: Boolean = false, // 是否已下载\n    28\t    val syncInfo: SubtitleSyncInfo? = null, // 同步信息\n    29\t    val metadata: Map&lt;String, String&gt; = emptyMap() // 额外元数据\n    30\t) : Parcelable {\n    31\t    \n    32\t    /**\n    33\t     * 获取本地字幕文件\n    34\t     */\n    35\t    fun getLocalFile(): File? {\n    36\t        return if (isDownloaded &amp;&amp; localPath.isNotEmpty()) {\n    37\t            File(localPath).takeIf { it.exists() }\n    38\t        } else null\n    39\t    }\n    40\t    \n    41\t    /**\n    42\t     * 检查字幕是否可用\n    43\t     */\n    44\t    fun isAvailable(): Boolean {\n    45\t        return isDownloaded &amp;&amp; getLocalFile() != null\n    46\t    }\n    47\t    \n    48\t    /**\n    49\t     * 获取字幕描述信息\n    50\t     */\n    51\t    fun getDescription(): String {\n    52\t        val parts = mutableListOf&lt;String&gt;()\n    53\t        if (languageName.isNotEmpty()) parts.add(languageName)\n    54\t        if (rating &gt; 0) parts.add(\&quot;评分: %.1f\&quot;.format(rating))\n    55\t        if (downloadCount &gt; 0) parts.add(\&quot;下载: $downloadCount\&quot;)\n    56\t        return parts.joinToString(\&quot; | \&quot;)\n    57\t    }\n    58\t    \n    59\t    /**\n    60\t     * 获取显示标题\n    61\t     */\n    62\t    fun getDisplayTitle(): String {\n    63\t        return if (title.isNotEmpty()) title else \&quot;字幕 - $languageName\&quot;\n    64\t    }\n    65\t}\n    66\t\n    67\t/**\n    68\t * 字幕格式枚举\n    69\t */\n    70\t@Parcelize\n    71\tenum class SubtitleFormat(val extension: String, val mimeType: String) : Parcelable {\n    72\t    SRT(\&quot;srt\&quot;, \&quot;application/x-subrip\&quot;),\n    73\t    ASS(\&quot;ass\&quot;, \&quot;text/x-ssa\&quot;),\n    74\t    SSA(\&quot;ssa\&quot;, \&quot;text/x-ssa\&quot;),\n    75\t    VTT(\&quot;vtt\&quot;, \&quot;text/vtt\&quot;),\n    76\t    SUB(\&quot;sub\&quot;, \&quot;text/x-subviewer\&quot;),\n    77\t    IDX(\&quot;idx\&quot;, \&quot;application/x-subtitle\&quot;),\n    78\t    SMI(\&quot;smi\&quot;, \&quot;application/x-sami\&quot;),\n    79\t    TXT(\&quot;txt\&quot;, \&quot;text/plain\&quot;);\n    80\t    \n    81\t    companion object {\n    82\t        fun fromExtension(extension: String): SubtitleFormat {\n    83\t            return values().find { \n    84\t                it.extension.equals(extension, ignoreCase = true) \n    85\t            } ?: SRT\n    86\t        }\n    87\t        \n    88\t        fun fromFileName(fileName: String): SubtitleFormat {\n    89\t            val ext = fileName.substringAfterLast('.', \&quot;\&quot;)\n    90\t            return fromExtension(ext)\n    91\t        }\n    92\t    }\n    93\t}\n    94\t\n    95\t/**\n    96\t * 字幕来源枚举\n    97\t */\n    98\t@Parcelize\n    99\tenum class SubtitleSource(val displayName: String, val baseUrl: String) : Parcelable {\n   100\t    OPENSUBTITLES(\&quot;OpenSubtitles\&quot;, \&quot;https://api.opensubtitles.com\&quot;),\n   101\t    SUBSCENE(\&quot;Subscene\&quot;, \&quot;https://subscene.com\&quot;),\n   102\t    YIFYSUBTITLES(\&quot;YifySubtitles\&quot;, \&quot;https://yifysubtitles.org\&quot;),\n   103\t    SUBDL(\&quot;SubDL\&quot;, \&quot;https://subdl.com\&quot;),\n   104\t    LOCAL(\&quot;本地字幕\&quot;, \&quot;\&quot;),\n   105\t    MANUAL(\&quot;手动导入\&quot;, \&quot;\&quot;),\n   106\t    UNKNOWN(\&quot;未知来源\&quot;, \&quot;\&quot;);\n   107\t    \n   108\t    val isOnline: Boolean\n   109\t        get() = baseUrl.isNotEmpty()\n   110\t}\n   111\t\n   112\t/**\n   113\t * 字幕同步信息\n   114\t */\n   115\t@Parcelize\n   116\tdata class SubtitleSyncInfo(\n   117\t    val offsetMs: Long = 0L, // 时间偏移（毫秒）\n   118\t    val speedRatio: Float = 1.0f, // 播放速度比例\n   119\t    val fps: Float = 0.0f, // 帧率\n   120\t    val isAutoSynced: Boolean = false, // 是否自动同步\n   121\t    val confidence: Float = 0.0f // 同步置信度 (0.0-1.0)\n   122\t) : Parcelable {\n   123\t    \n   124\t    /**\n   125\t     * 应用时间偏移\n   126\t     */\n   127\t    fun applyOffset(originalTimeMs: Long): Long {\n   128\t        return ((originalTimeMs * speedRatio) + offsetMs).toLong()\n   129\t    }\n   130\t}...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/SubtitleMatcher.kt\n...\n   577\t    \n   578\t    private data class FileNameInfo(\n   579\t        val title: String,\n   580\t        val year: Int,\n   581\t        val season: Int,\n   582\t        val episode: Int,\n   583\t        val resolution: String,\n   584\t        val releaseGroup: String\n   585\t    )\n   586\t}\n   587\t\n   588\t/**\n   589\t * 字幕匹配结果\n   590\t */\n   591\tdata class SubtitleMatch(\n   592\t    val subtitle: Subtitle,\n   593\t    val similarity: Float, // 相似度 (0.0-1.0)\n   594\t    val confidence: Float, // 置信度 (0.0-1.0)\n   595\t    val matchReasons: List&lt;MatchReason&gt; = emptyList()\n   596\t) {\n   597\t    val isExcellentMatch: Boolean\n   598\t        get() = similarity &gt;= 0.9f\n   599\t        \n   600\t    val isGoodMatch: Boolean\n   601\t        get() = similarity &gt;= 0.7f\n   602\t        \n   603\t    val qualityLevel: MatchQuality\n   604\t        get() = when {\n   605\t            similarity &gt;= 0.9f -&gt; MatchQuality.EXCELLENT\n   606\t            similarity &gt;= 0.7f -&gt; MatchQuality.GOOD\n   607\t            similarity &gt;= 0.5f -&gt; MatchQuality.FAIR\n   608\t            else -&gt; MatchQuality.POOR\n   609\t        }\n   610\t}\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/SubtitleSearchService.kt\n...\n    50\t\n    51\t/**\n    52\t * API限制信息\n    53\t */\n    54\tdata class ApiLimitInfo(\n    55\t    val requestsPerDay: Int = 200, // 每日请求限制\n    56\t    val requestsUsed: Int = 0, // 已使用请求数\n    57\t    val remainingRequests: Int = 200, // 剩余请求数\n    58\t    val resetTime: Long = 0L, // 重置时间戳\n    59\t    val isLimited: Boolean = false // 是否受限\n    60\t) {\n    61\t    val canMakeRequest: Boolean\n    62\t        get() = !isLimited &amp;&amp; remainingRequests &gt; 0\n    63\t}\n    64\t\n    65\t/**\n    66\t * 搜索结果\n    67\t */\n    68\tdata class SubtitleSearchResult(\n    69\t    val subtitles: List&lt;Subtitle&gt; = emptyList(),\n    70\t    val totalCount: Int = 0,\n    71\t    val searchTime: Long = 0L, // 搜索耗时（毫秒）\n    72\t    val source: SubtitleSource = SubtitleSource.UNKNOWN,\n    73\t    val errors: List&lt;String&gt; = emptyList()\n    74\t) {\n    75\t    val isSuccess: Boolean\n    76\t        get() = errors.isEmpty()\n    77\t        \n    78\t    val hasResults: Boolean\n    79\t        get() = subtitles.isNotEmpty()\n    80\t}...\nPath: app/src/main/java/com/tvplayer/webdav/data/model/SubtitleConfig.kt\n...\n     6\t\n     7\t/**\n     8\t * 字幕配置模型\n     9\t */\n    10\t@Parcelize\n    11\tdata class SubtitleConfig(\n    12\t    // 显示设置\n    13\t    val isEnabled: Boolean = true, // 是否启用字幕\n    14\t    val primaryLanguage: String = \&quot;zh\&quot;, // 首选语言\n    15\t    val fallbackLanguage: String = \&quot;en\&quot;, // 备用语言\n    16\t    val autoSelectLanguage: Boolean = true, // 自动选择语言\n    17\t    \n    18\t    // 样式设置\n    19\t    val textSize: Float = 16.0f, // 字体大小 (sp)\n    20\t    val textColor: Int = Color.WHITE, // 字体颜色\n    21\t    val backgroundColor: Int = Color.TRANSPARENT, // 背景颜色\n    22\t    val outlineColor: Int = Color.BLACK, // 描边颜色\n    23\t    val outlineWidth: Float = 1.0f, // 描边宽度\n    24\t    val shadowColor: Int = Color.BLACK, // 阴影颜色\n    25\t    val shadowRadius: Float = 1.0f, // 阴影半径\n    26\t    val shadowOffsetX: Float = 1.0f, // 阴影X偏移\n    27\t    val shadowOffsetY: Float = 1.0f, // 阴影Y偏移\n    28\t    \n    29\t    // 位置设置\n    30\t    val position: SubtitlePosition = SubtitlePosition.BOTTOM, // 字幕位置\n    31\t    val marginHorizontal: Float = 32.0f, // 水平边距 (dp)\n    32\t    val marginVertical: Float = 48.0f, // 垂直边距 (dp)\n    33\t    val alignment: SubtitleAlignment = SubtitleAlignment.CENTER, // 对齐方式\n    34\t    \n    35\t    // 字体设置\n    36\t    val fontFamily: String = \&quot;default\&quot;, // 字体族\n    37\t    val isBold: Boolean = false, // 是否粗体\n    38\t    val isItalic: Boolean = false, // 是否斜体\n    39\t    \n    40\t    // 同步设置\n    41\t    val globalOffsetMs: Long = 0L, // 全局时间偏移（毫秒）\n    42\t    val autoSync: Boolean = true, // 自动同步\n    43\t    val syncSensitivity: Float = 0.5f, // 同步敏感度 (0.0-1.0)\n    44\t    \n    45\t    // 下载设置\n    46\t    val autoDownload: Boolean = true, // 自动下载字幕\n    47\t    val downloadQuality: SubtitleQuality = SubtitleQuality.BEST, // 下载质量偏好\n    48\t    val maxCacheSize: Long = 100 * 1024 * 1024L, // 最大缓存大小 (100MB)\n    49\t    val cacheExpireDays: Int = 30, // 缓存过期天数\n    50\t    \n    51\t    // 搜索设置\n    52\t    val enabledSources: Set&lt;SubtitleSource&gt; = setOf(\n    53\t        SubtitleSource.OPENSUBTITLES,\n    54\t        SubtitleSource.SUBSCENE\n    55\t    ), // 启用的字幕源\n    56\t    val searchTimeout: Int = 10, // 搜索超时时间（秒）\n    57\t    val maxResults: Int = 20, // 最大搜索结果数\n    58\t    \n    59\t    // 高级设置\n    60\t    val encoding: String = \&quot;UTF-8\&quot;, // 默认编码\n    61\t    val lineSpacing: Float = 1.2f, // 行间距\n    62\t    val maxLines: Int = 3, // 最大行数\n    63\t    val wordWrap: Boolean = true, // 自动换行\n    64\t    val fadeInDuration: Long = 200L, // 淡入时长（毫秒）\n    65\t    val fadeOutDuration: Long = 200L // 淡出时长（毫秒）\n    66\t) : Parcelable {\n    67\t    \n    68\t    companion object {\n    69\t        /**\n    70\t         * 获取默认配置\n    71\t         */\n    72\t        fun getDefault(): SubtitleConfig = SubtitleConfig()\n    73\t        \n    74\t        /**\n    75\t         * 获取简体中文优化配置\n    76\t         */\n    77\t        fun getChineseOptimized(): SubtitleConfig = SubtitleConfig(\n    78\t            primaryLanguage = \&quot;zh-cn\&quot;,\n    79\t            fallbackLanguage = \&quot;zh\&quot;,\n    80\t            textSize = 18.0f,\n    81\t            outlineWidth = 1.5f,\n    82\t            marginVertical = 60.0f\n    83\t        )\n    84\t        \n    85\t        /**\n    86\t         * 获取英文优化配置\n    87\t         */\n    88\t        fun getEnglishOptimized(): SubtitleConfig = SubtitleConfig(\n    89\t            primaryLanguage = \&quot;en\&quot;,\n    90\t            fallbackLanguage = \&quot;en-us\&quot;,\n    91\t            textSize = 16.0f,\n    92\t            fontFamily = \&quot;sans-serif\&quot;\n    93\t        )\n    94\t    }\n    95\t    \n    96\t    /**\n    97\t     * 检查配置是否有效\n    98\t     */\n    99\t    fun isValid(): Boolean {\n   100\t        return textSize &gt; 0 &amp;&amp; \n   101\t               marginHorizontal &gt;= 0 &amp;&amp; \n   102\t               marginVertical &gt;= 0 &amp;&amp;\n   103\t               outlineWidth &gt;= 0 &amp;&amp;\n   104\t               maxCacheSize &gt; 0 &amp;&amp;\n   105\t               searchTimeout &gt; 0 &amp;&amp;\n   106\t               maxResults &gt; 0\n   107\t    }\n   108\t    \n   109\t    /**\n   110\t     * 应用全局时间偏移\n   111\t     */\n   112\t    fun applyGlobalOffset(timeMs: Long): Long {\n   113\t        return timeMs + globalOffsetMs\n   114\t    }\n   115\t}\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/OpenSubtitlesService.kt\n...\n   343\t        \n   344\t        return Subtitle(\n   345\t            id = id,\n   346\t            title = attributes.optString(\&quot;release\&quot;, \&quot;\&quot;),\n   347\t            language = language,\n   348\t            languageName = getLanguageDisplayName(language),\n   349\t            format = SubtitleFormat.SRT, // OpenSubtitles主要提供SRT\n   350\t            downloadUrl = file?.optString(\&quot;link\&quot;, \&quot;\&quot;) ?: \&quot;\&quot;,\n   351\t            fileSize = file?.optLong(\&quot;file_size\&quot;, 0L) ?: 0L,\n   352\t            source = SubtitleSource.OPENSUBTITLES,\n   353\t            rating = attributes.optDouble(\&quot;ratings\&quot;, 0.0).toFloat(),\n   354\t            downloadCount = attributes.optInt(\&quot;download_count\&quot;, 0),\n   355\t            uploadDate = parseUploadDate(attributes.optString(\&quot;upload_date\&quot;, \&quot;\&quot;)),\n   356\t            uploader = attributes.optString(\&quot;uploader\&quot;, \&quot;\&quot;),\n   357\t            metadata = mapOf(\n   358\t                \&quot;release\&quot; to attributes.optString(\&quot;release\&quot;, \&quot;\&quot;),\n   359\t                \&quot;comments\&quot; to attributes.optString(\&quot;comments\&quot;, \&quot;\&quot;),\n   360\t                \&quot;hearing_impaired\&quot; to attributes.optBoolean(\&quot;hearing_impaired\&quot;, false).toString()\n   361\t            )\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/subtitle/SubtitleManagerTest.kt\n...\n   200\t    \n   201\t    private fun createTestSubtitle(\n   202\t        id: String,\n   203\t        title: String,\n   204\t        language: String,\n   205\t        rating: Float = 0.0f,\n   206\t        downloadCount: Int = 100,\n   207\t        isDownloaded: Boolean = false\n   208\t    ): Subtitle {\n   209\t        return Subtitle(\n   210\t            id = id,\n   211\t            title = title,\n   212\t            language = language,\n   213\t            languageName = when (language) {\n   214\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   215\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   216\t                \\\&quot;ja\\\&quot; -&gt; \\\&quot;日本語\\\&quot;\n   217\t                else -&gt; language.uppercase()\n   218\t            },\n   219\t            format = SubtitleFormat.SRT,\n   220\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   221\t            localPath = if (isDownloaded) \\\&quot;/test/cache/subtitle_$id.srt\\\&quot; else \\\&quot;\\\&quot;,\n   222\t            fileSize = 1024L * 50, // 50KB\n   223\t            source = SubtitleSource.OPENSUBTITLES,\n   224\t            rating = rating,\n   225\t            downloadCount = downloadCount,\n   226\t            uploadDate = System.currentTimeMillis() - 86400000L, // 1天前\n   227\t            uploader = \\\&quot;test_user\\\&quot;,\n   228\t            isDownloaded = isDownloaded\n   229\t        )\n   230\t    }\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/storage/SubtitleCacheTest.kt\n...\n   255\t    \n   256\t    // 辅助方法\n   257\t    \n   258\t    private fun createTestSubtitle(\n   259\t        id: String,\n   260\t        title: String,\n   261\t        language: String,\n   262\t        rating: Float = 0.0f,\n   263\t        downloadCount: Int = 100,\n   264\t        isDownloaded: Boolean = true,\n   265\t        uploadDate: Long = System.currentTimeMillis()\n   266\t    ): Subtitle {\n   267\t        return Subtitle(\n   268\t            id = id,\n   269\t            title = title,\n   270\t            language = language,\n   271\t            languageName = when (language) {\n   272\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   273\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   274\t                \\\&quot;ja\\\&quot; -&gt; \\\&quot;日本語\\\&quot;\n   275\t                else -&gt; language.uppercase()\n   276\t            },\n   277\t            format = SubtitleFormat.SRT,\n   278\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   279\t            localPath = if (isDownloaded) \\\&quot;/test/cache/subtitle_$id.srt\\\&quot; else \\\&quot;\\\&quot;,\n   280\t            fileSize = 1024L * 50,\n   281\t            source = SubtitleSource.OPENSUBTITLES,\n   282\t            rating = rating,\n   283\t            downloadCount = downloadCount,\n   284\t            uploadDate = uploadDate,\n   285\t            uploader = \\\&quot;test_user\\\&quot;,\n   286\t            isDownloaded = isDownloaded\n   287\t        )\n   288\t    }\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/subtitle/SubtitleMatcherTest.kt\n...\n   246\t    \n   247\t    private fun createTestSubtitle(\n   248\t        id: String,\n   249\t        title: String,\n   250\t        language: String,\n   251\t        rating: Float = 0.0f,\n   252\t        downloadCount: Int = 100,\n   253\t        season: Int? = null,\n   254\t        episode: Int? = null,\n   255\t        year: Int? = null\n   256\t    ): Subtitle {\n   257\t        val metadata = mutableMapOf&lt;String, String&gt;()\n   258\t        season?.let { metadata[\\\&quot;season_number\\\&quot;] = it.toString() }\n   259\t        episode?.let { metadata[\\\&quot;episode_number\\\&quot;] = it.toString() }\n   260\t        year?.let { metadata[\\\&quot;year\\\&quot;] = it.toString() }\n   261\t        \n   262\t        return Subtitle(\n   263\t            id = id,\n   264\t            title = title,\n   265\t            language = language,\n   266\t            languageName = when (language) {\n   267\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   268\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   269\t                \\\&quot;ko\\\&quot; -&gt; \\\&quot;한국어\\\&quot;\n   270\t                else -&gt; language.uppercase()\n   271\t            },\n   272\t            format = SubtitleFormat.SRT,\n   273\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   274\t            localPath = \\\&quot;/test/cache/subtitle_$id.srt\\\&quot;,\n   275\t            fileSize = 1024L * 50,\n   276\t            source = SubtitleSource.OPENSUBTITLES,\n   277\t            rating = rating,\n   278\t            downloadCount = downloadCount,\n   279\t            uploadDate = System.currentTimeMillis() - 86400000L,\n   280\t            uploader = \\\&quot;test_user\\\&quot;,\n   281\t            isDownloaded = true,\n   282\t            metadata = metadata\n   283\t        )\n   284\t    }\n   285\t}\&quot;, \&quot;original_text\&quot;: \&quot;\&quot;, \&quot;replace_all\&quot;: false}]...\nPath: app/src/main/java/com/tvplayer/webdav/data/model/SubtitleSearchRequest.kt\n...\n    32\t    \n    33\t    // 搜索参数\n    34\t    val languages: List&lt;String&gt; = listOf(\&quot;zh\&quot;, \&quot;en\&quot;), // 搜索语言列表\n    35\t    val sources: Set&lt;SubtitleSource&gt; = setOf(SubtitleSource.OPENSUBTITLES), // 搜索源\n    36\t    val maxResults: Int = 20, // 最大结果数\n    37\t    val timeoutSeconds: Int = 10, // 超时时间\n    38\t    val minRating: Float = 0.0f, // 最小评分过滤\n    39\t    val onlyHD: Boolean = false, // 仅搜索高清字幕\n    40\t    \n    41\t    // 高级选项\n    42\t    val fuzzyMatch: Boolean = true, // 模糊匹配\n    43\t    val includeHearingImpaired: Boolean = false, // 包含听力障碍字幕\n    44\t    val excludeMachineTranslated: Boolean = true, // 排除机器翻译\n    45\t    val preferredFormats: List&lt;SubtitleFormat&gt; = listOf(SubtitleFormat.SRT, SubtitleFormat.ASS) // 偏好格式\n    46\t) : Parcelable {\n    47\t    \n    48\t    /**\n    49\t     * 从MediaItem创建搜索请求\n    50\t     */\n    51\t    companion object {\n    52\t        fun fromMediaItem(mediaItem: MediaItem, config: SubtitleConfig): SubtitleSearchRequest {\n    53\t            return SubtitleSearchRequest(\n    54\t                mediaType = mediaItem.mediaType,\n    55\t                title = mediaItem.title,\n    56\t                originalTitle = mediaItem.originalTitle ?: \&quot;\&quot;,\n    57\t                year = extractYearFromDate(mediaItem.releaseDate),\n    58\t                imdbId = \&quot;\&quot;, // MediaItem中暂无此属性\n    59\t                tmdbId = 0, // MediaItem中暂无此属性\n    60\t                seasonNumber = mediaItem.seasonNumber ?: 0,\n    61\t                episodeNumber = mediaItem.episodeNumber ?: 0,\n    62\t                fileName = extractFileNameFromPath(mediaItem.filePath),\n    63\t                fileSize = mediaItem.fileSize,\n    64\t                duration = mediaItem.duration * 1000, // 转换为毫秒\n    65\t                languages = listOf(config.primaryLanguage, config.fallbackLanguage).distinct(),\n    66\t                sources = config.enabledSources,\n    67\t                maxResults = config.maxResults,\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt\n...\n    60\t    \n    61\t    /**\n    62\t     * 保存字幕到缓存\n    63\t     * @param subtitle 字幕信息\n    64\t     * @param mediaId 关联的媒体ID（可选）\n    65\t     */\n    66\t    suspend fun saveSubtitle(subtitle: Subtitle, mediaId: String? = null) {\n    67\t        withContext(Dispatchers.IO) {\n    68\t            cacheMutex.withLock {\n    69\t                try {\n    70\t                    // 保存到内存缓存\n    71\t                    subtitleMemoryCache[subtitle.id] = subtitle\n    72\t                    \n    73\t                    // 如果有关联媒体，建立映射关系\n    74\t                    mediaId?.let { id -&gt;\n    75\t                        val subtitleIds = mediaMappingCache.getOrPut(id) { mutableSetOf() }\n    76\t                        subtitleIds.add(subtitle.id)\n    77\t                    }\n    78\t                    \n    79\t                    // 持久化到SharedPreferences\n    80\t                    persistCacheToPreferences()\n    81\t                    \n    82\t                    Log.d(TAG, \&quot;Subtitle cached: ${subtitle.id} for media: $mediaId\&quot;)\n    83\t                    \n    84\t                } catch (e: Exception) {\n    85\t                    Log.e(TAG, \&quot;Er...&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01SDHvcjHgyMiRnhZ1farxFU&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;E:/1-test/android-tv-player&quot;,&quot;folderRoot&quot;:&quot;E:/1-test/android-tv-player&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-08-22T06:54:18.385Z&quot;,&quot;response_text&quot;:&quot;Now I can see the issues. Looking at the compilation errors and the code, I can identify the problems:\n\n1. **Line 430**: The code is using `kotlinx.coroutines.GlobalScope.launch` which is deprecated and should be avoided. This is causing a compilation error.\n2. **Lines 432-433**: The suspend functions `cleanExpiredSubtitles()` and `cleanupToSize()` are being called from a non-suspend context (inside `init` block).\n\nLet me check if there are any other issues by looking at the imports and dependencies:\n&quot;,&quot;workspace_file_chunks&quot;:[]}],&quot;feedbackStates&quot;:{&quot;temp-fe-dd16e043-f5d2-4543-b2e8-0857fa3a5f5b&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-5672dc85-02a7-49c0-8a74-4be1e462e503&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-34b49ced-b183-492b-bd32-45efc34875fd&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;}},&quot;toolUseStates&quot;:{&quot;797a6496-b869-4533-83fd-ae3087d1be9c;toolu_vrtx_01ELnoWc6SPsCEHCDDduVALs&quot;:{&quot;requestId&quot;:&quot;797a6496-b869-4533-83fd-ae3087d1be9c&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01ELnoWc6SPsCEHCDDduVALs&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt:\n     1\tpackage com.tvplayer.webdav.data.storage\n     2\t\n     3\timport android.content.Context\n     4\timport android.content.SharedPreferences\n     5\timport android.util.Log\n     6\timport com.google.gson.Gson\n     7\timport com.google.gson.reflect.TypeToken\n     8\timport com.tvplayer.webdav.data.model.Subtitle\n     9\timport dagger.hilt.android.qualifiers.ApplicationContext\n    10\timport kotlinx.coroutines.Dispatchers\n    11\timport kotlinx.coroutines.sync.Mutex\n    12\timport kotlinx.coroutines.sync.withLock\n    13\timport kotlinx.coroutines.withContext\n    14\timport java.io.File\n    15\timport java.util.concurrent.ConcurrentHashMap\n    16\timport javax.inject.Inject\n    17\timport javax.inject.Singleton\n    18\t\n    19\t/**\n    20\t * 字幕缓存管理器\n    21\t * 负责字幕信息的本地存储、检索和清理\n    22\t */\n    23\t@Singleton\n    24\tclass SubtitleCache @Inject constructor(\n    25\t    @ApplicationContext private val context: Context,\n    26\t    private val gson: Gson\n    27\t) {\n    28\t    \n    29\t    companion object {\n    30\t        private const val TAG = \&quot;SubtitleCache\&quot;\n    31\t        private const val PREFS_NAME = \&quot;subtitle_cache\&quot;\n    32\t        private const val KEY_SUBTITLES = \&quot;cached_subtitles\&quot;\n    33\t        private const val KEY_MEDIA_MAPPING = \&quot;media_subtitle_mapping\&quot;\n    34\t        private const val KEY_LAST_CLEANUP = \&quot;last_cleanup\&quot;\n    35\t        private const val SUBTITLE_DIR = \&quot;subtitles\&quot;\n    36\t        private const val MAX_CACHE_SIZE = 100 * 1024 * 1024L // 100MB\n    37\t        private const val CLEANUP_INTERVAL_DAYS = 7\n    38\t    }\n    39\t    \n    40\t    private val preferences: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)\n    41\t    private val cacheMutex = Mutex()\n    42\t    \n    43\t    // 内存缓存\n    44\t    private val subtitleMemoryCache = ConcurrentHashMap&lt;String, Subtitle&gt;()\n    45\t    private val mediaMappingCache = ConcurrentHashMap&lt;String, MutableSet&lt;String&gt;&gt;()\n    46\t    \n    47\t    private val subtitleDir: File by lazy {\n    48\t        File(context.cacheDir, SUBTITLE_DIR).apply {\n    49\t            if (!exists()) mkdirs()\n    50\t        }\n    51\t    }\n    52\t    \n    53\t    init {\n    54\t        // 启动时加载缓存\n    55\t        loadCacheFromPreferences()\n    56\t        \n    57\t        // 检查是否需要清理\n    58\t        checkAndCleanupIfNeeded()\n    59\t    }\n    60\t    \n    61\t    /**\n    62\t     * 保存字幕到缓存\n    63\t     * @param subtitle 字幕信息\n    64\t     * @param mediaId 关联的媒体ID（可选）\n    65\t     */\n    66\t    suspend fun saveSubtitle(subtitle: Subtitle, mediaId: String? = null) {\n    67\t        withContext(Dispatchers.IO) {\n    68\t            cacheMutex.withLock {\n    69\t                try {\n    70\t                    // 保存到内存缓存\n    71\t                    subtitleMemoryCache[subtitle.id] = subtitle\n    72\t                    \n    73\t                    // 如果有关联媒体，建立映射关系\n    74\t                    mediaId?.let { id -&gt;\n    75\t                        val subtitleIds = mediaMappingCache.getOrPut(id) { mutableSetOf() }\n    76\t                        subtitleIds.add(subtitle.id)\n    77\t                    }\n    78\t                    \n    79\t                    // 持久化到SharedPreferences\n    80\t                    persistCacheToPreferences()\n    81\t                    \n    82\t                    Log.d(TAG, \&quot;Subtitle cached: ${subtitle.id} for media: $mediaId\&quot;)\n    83\t                    \n    84\t                } catch (e: Exception) {\n    85\t                    Log.e(TAG, \&quot;Error saving subtitle to cache\&quot;, e)\n    86\t                }\n    87\t            }\n    88\t        }\n    89\t    }\n    90\t    \n    91\t    /**\n    92\t     * 获取媒体相关的字幕\n    93\t     * @param mediaId 媒体ID\n    94\t     * @return 字幕列表\n    95\t     */\n    96\t    fun getSubtitles(mediaId: String): List&lt;Subtitle&gt; {\n    97\t        return try {\n    98\t            val subtitleIds = mediaMappingCache[mediaId] ?: return emptyList()\n    99\t            subtitleIds.mapNotNull { subtitleMemoryCache[it] }\n   100\t                .filter { it.isAvailable() } // 只返回可用的字幕\n   101\t        } catch (e: Exception) {\n   102\t            Log.e(TAG, \&quot;Error getting subtitles for media: $mediaId\&quot;, e)\n   103\t            emptyList()\n   104\t        }\n   105\t    }\n   106\t    \n   107\t    /**\n   108\t     * 根据ID获取字幕\n   109\t     * @param subtitleId 字幕ID\n   110\t     * @return 字幕信息，如果不存在返回null\n   111\t     */\n   112\t    fun getSubtitle(subtitleId: String): Subtitle? {\n   113\t        return subtitleMemoryCache[subtitleId]\n   114\t    }\n   115\t    \n   116\t    /**\n   117\t     * 搜索字幕\n   118\t     * @param query 搜索关键词\n   119\t     * @param language 语言过滤（可选）\n   120\t     * @return 匹配的字幕列表\n   121\t     */\n   122\t    fun searchSubtitles(query: String, language: String? = null): List&lt;Subtitle&gt; {\n   123\t        return try {\n   124\t            val lowerQuery = query.lowercase()\n   125\t            subtitleMemoryCache.values.filter { subtitle -&gt;\n   126\t                val matchesQuery = subtitle.title.lowercase().contains(lowerQuery) ||\n   127\t                                 subtitle.languageName.lowercase().contains(lowerQuery)\n   128\t                \n   129\t                val matchesLanguage = language?.let { lang -&gt;\n   130\t                    subtitle.language.equals(lang, ignoreCase = true) ||\n   131\t                    subtitle.language.startsWith(lang, ignoreCase = true)\n   132\t                } ?: true\n   133\t                \n   134\t                matchesQuery &amp;&amp; matchesLanguage &amp;&amp; subtitle.isAvailable()\n   135\t            }.sortedByDescending { it.rating }\n   136\t        } catch (e: Exception) {\n   137\t            Log.e(TAG, \&quot;Error searching subtitles\&quot;, e)\n   138\t            emptyList()\n   139\t        }\n   140\t    }\n   141\t    \n   142\t    /**\n   143\t     * 删除字幕\n   144\t     * @param subtitleId 字幕ID\n   145\t     */\n   146\t    suspend fun removeSubtitle(subtitleId: String) {\n   147\t        withContext(Dispatchers.IO) {\n   148\t            cacheMutex.withLock {\n   149\t                try {\n   150\t                    val subtitle = subtitleMemoryCache[subtitleId]\n   151\t                    \n   152\t                    // 删除本地文件\n   153\t                    subtitle?.let { sub -&gt;\n   154\t                        if (sub.isDownloaded &amp;&amp; sub.localPath.isNotEmpty()) {\n   155\t                            val file = File(sub.localPath)\n   156\t                            if (file.exists() &amp;&amp; file.delete()) {\n   157\t                                Log.d(TAG, \&quot;Deleted subtitle file: ${sub.localPath}\&quot;)\n   158\t                            }\n   159\t                        }\n   160\t                    }\n   161\t                    \n   162\t                    // 从内存缓存移除\n   163\t                    subtitleMemoryCache.remove(subtitleId)\n   164\t                    \n   165\t                    // 从媒体映射中移除\n   166\t                    mediaMappingCache.values.forEach { subtitleIds -&gt;\n   167\t                        subtitleIds.remove(subtitleId)\n   168\t                    }\n   169\t                    \n   170\t                    // 持久化更改\n   171\t                    persistCacheToPreferences()\n   172\t                    \n   173\t                    Log.d(TAG, \&quot;Subtitle removed from cache: $subtitleId\&quot;)\n   174\t                    \n   175\t                } catch (e: Exception) {\n   176\t                    Log.e(TAG, \&quot;Error removing subtitle from cache\&quot;, e)\n   177\t                }\n   178\t            }\n   179\t        }\n   180\t    }\n   181\t    \n   182\t    /**\n   183\t     * 清理过期字幕\n   184\t     * @param expireDays 过期天数\n   185\t     */\n   186\t    suspend fun cleanExpiredSubtitles(expireDays: Int = 30) {\n   187\t        withContext(Dispatchers.IO) {\n   188\t            cacheMutex.withLock {\n   189\t                try {\n   190\t                    val expireTime = System.currentTimeMillis() - (expireDays * 24 * 60 * 60 * 1000L)\n   191\t                    val expiredSubtitleIds = mutableListOf&lt;String&gt;()\n   192\t                    \n   193\t                    subtitleMemoryCache.values.forEach { subtitle -&gt;\n   194\t                        if (subtitle.uploadDate &gt; 0 &amp;&amp; subtitle.uploadDate &lt; expireTime) {\n   195\t                            expiredSubtitleIds.add(subtitle.id)\n   196\t                        }\n   197\t                    }\n   198\t                    \n   199\t                    // 删除过期字幕\n   200\t                    for (subtitleId in expiredSubtitleIds) {\n   201\t                        try {\n   202\t                            val subtitle = subtitleMemoryCache[subtitleId]\n   203\t                            \n   204\t                            // 删除本地文件\n   205\t                            subtitle?.let { sub -&gt;\n   206\t                                if (sub.isDownloaded &amp;&amp; sub.localPath.isNotEmpty()) {\n   207\t                                    val file = File(sub.localPath)\n   208\t                                    if (file.exists() &amp;&amp; file.delete()) {\n   209\t                                        Log.d(TAG, \&quot;Deleted subtitle file: ${sub.localPath}\&quot;)\n   210\t                                    }\n   211\t                                }\n   212\t                            }\n   213\t                            \n   214\t                            // 从内存缓存移除\n   215\t                            subtitleMemoryCache.remove(subtitleId)\n   216\t                            \n   217\t                            // 从媒体映射中移除\n   218\t                            mediaMappingCache.values.forEach { subtitleIds -&gt;\n   219\t                                subtitleIds.remove(subtitleId)\n   220\t                            }\n   221\t                        } catch (e: Exception) {\n   222\t                            Log.e(TAG, \&quot;Error removing expired subtitle: $subtitleId\&quot;, e)\n   223\t                        }\n   224\t                    }\n   225\t                    \n   226\t                    // 持久化更改\n   227\t                    persistCacheToPreferences()\n   228\t                    \n   229\t                    // 清理孤立的字幕文件\n   230\t                    cleanOrphanedFiles()\n   231\t                    \n   232\t                    // 更新最后清理时间\n   233\t                    preferences.edit()\n   234\t                        .putLong(KEY_LAST_CLEANUP, System.currentTimeMillis())\n   235\t                        .apply()\n   236\t                    \n   237\t                    Log.d(TAG, \&quot;Cleaned ${expiredSubtitleIds.size} expired subtitles\&quot;)\n   238\t                    \n   239\t                } catch (e: Exception) {\n   240\t                    Log.e(TAG, \&quot;Error cleaning expired subtitles\&quot;, e)\n   241\t                }\n   242\t            }\n   243\t        }\n   244\t    }\n   245\t    \n   246\t    /**\n   247\t     * 清理缓存以释放空间\n   248\t     * @param targetSize 目标大小（字节）\n   249\t     */\n   250\t    suspend fun cleanupToSize(targetSize: Long = MAX_CACHE_SIZE) {\n   251\t        withContext(Dispatchers.IO) {\n   252\t            cacheMutex.withLock {\n   253\t                try {\n   254\t                    val currentSize = getCacheSize()\n   255\t                    if (currentSize &lt;= targetSize) {\n   256\t                        return@withLock\n   257\t                    }\n   258\t                    \n   259\t                    Log.d(TAG, \&quot;Cache size: $currentSize bytes, target: $targetSize bytes\&quot;)\n   260\t                    \n   261\t                    // 按最后访问时间排序，删除最老的文件\n   262\t                    val subtitleFiles = subtitleDir.listFiles()?.sortedBy { it.lastModified() } ?: return@withLock\n   263\t                    var freedSize = 0L\n   264\t                    \n   265\t                    for (file in subtitleFiles) {\n   266\t                        if (currentSize - freedSize &lt;= targetSize) {\n   267\t                            break\n   268\t                        }\n   269\t                        \n   270\t                        val fileSize = file.length()\n   271\t                        if (file.delete()) {\n   272\t                            freedSize += fileSize\n   273\t                            \n   274\t                            // 从缓存中移除对应的字幕记录（非异步方式）\n   275\t                            val subtitleToRemove = subtitleMemoryCache.values.find { \n   276\t                                it.localPath == file.absolutePath \n   277\t                            }\n   278\t                            subtitleToRemove?.let { subtitle -&gt;\n   279\t                                // 直接从内存缓存移除，避免suspend函数调用\n   280\t                                subtitleMemoryCache.remove(subtitle.id)\n   281\t                                \n   282\t                                // 从媒体映射中移除\n   283\t                                mediaMappingCache.values.forEach { subtitleIds -&gt;\n   284\t                                    subtitleIds.remove(subtitle.id)\n   285\t                                }\n   286\t                            }\n   287\t                        }\n   288\t                    }\n   289\t                    \n   290\t                    Log.d(TAG, \&quot;Freed $freedSize bytes from cache\&quot;)\n   291\t                    \n   292\t                } catch (e: Exception) {\n   293\t                    Log.e(TAG, \&quot;Error cleaning up cache\&quot;, e)\n   294\t                }\n   295\t            }\n   296\t        }\n   297\t    }\n   298\t    \n   299\t    /**\n   300\t     * 获取缓存统计信息\n   301\t     */\n   302\t    fun getCacheStats(): CacheStats {\n   303\t        return try {\n   304\t            val totalSubtitles = subtitleMemoryCache.size\n   305\t            val downloadedSubtitles = subtitleMemoryCache.values.count { it.isDownloaded }\n   306\t            val cacheSize = getCacheSize()\n   307\t            val lastCleanup = preferences.getLong(KEY_LAST_CLEANUP, 0L)\n   308\t            \n   309\t            CacheStats(\n   310\t                totalSubtitles = totalSubtitles,\n   311\t                downloadedSubtitles = downloadedSubtitles,\n   312\t                cacheSize = cacheSize,\n   313\t                lastCleanup = lastCleanup\n   314\t            )\n   315\t        } catch (e: Exception) {\n   316\t            Log.e(TAG, \&quot;Error getting cache stats\&quot;, e)\n   317\t            CacheStats()\n   318\t        }\n   319\t    }\n   320\t    \n   321\t    /**\n   322\t     * 清空所有缓存\n   323\t     */\n   324\t    suspend fun clearAllCache() {\n   325\t        withContext(Dispatchers.IO) {\n   326\t            cacheMutex.withLock {\n   327\t                try {\n   328\t                    // 删除所有字幕文件\n   329\t                    subtitleDir.listFiles()?.forEach { file -&gt;\n   330\t                        file.delete()\n   331\t                    }\n   332\t                    \n   333\t                    // 清空内存缓存\n   334\t                    subtitleMemoryCache.clear()\n   335\t                    mediaMappingCache.clear()\n   336\t                    \n   337\t                    // 清空持久化数据\n   338\t                    preferences.edit().clear().apply()\n   339\t                    \n   340\t                    Log.d(TAG, \&quot;All cache cleared\&quot;)\n   341\t                    \n   342\t                } catch (e: Exception) {\n   343\t                    Log.e(TAG, \&quot;Error clearing cache\&quot;, e)\n   344\t                }\n   345\t            }\n   346\t        }\n   347\t    }\n   348\t    \n   349\t    // 私有辅助方法\n   350\t    \n   351\t    private fun loadCacheFromPreferences() {\n   352\t        try {\n   353\t            // 加载字幕数据\n   354\t            val subtitlesJson = preferences.getString(KEY_SUBTITLES, \&quot;\&quot;)\n   355\t            if (!subtitlesJson.isNullOrEmpty()) {\n   356\t                val type = object : TypeToken&lt;Map&lt;String, Subtitle&gt;&gt;() {}.type\n   357\t                val subtitles: Map&lt;String, Subtitle&gt; = gson.fromJson(subtitlesJson, type)\n   358\t                subtitleMemoryCache.putAll(subtitles)\n   359\t            }\n   360\t            \n   361\t            // 加载媒体映射\n   362\t            val mappingJson = preferences.getString(KEY_MEDIA_MAPPING, \&quot;\&quot;)\n   363\t            if (!mappingJson.isNullOrEmpty()) {\n   364\t                val type = object : TypeToken&lt;Map&lt;String, Set&lt;String&gt;&gt;&gt;() {}.type\n   365\t                val mapping: Map&lt;String, Set&lt;String&gt;&gt; = gson.fromJson(mappingJson, type)\n   366\t                mapping.forEach { (mediaId, subtitleIds) -&gt;\n   367\t                    mediaMappingCache[mediaId] = subtitleIds.toMutableSet()\n   368\t                }\n   369\t            }\n   370\t            \n   371\t            Log.d(TAG, \&quot;Loaded ${subtitleMemoryCache.size} subtitles from cache\&quot;)\n   372\t            \n   373\t        } catch (e: Exception) {\n   374\t            Log.e(TAG, \&quot;Error loading cache from preferences\&quot;, e)\n   375\t        }\n   376\t    }\n   377\t    \n   378\t    private fun persistCacheToPreferences() {\n   379\t        try {\n   380\t            val editor = preferences.edit()\n   381\t            \n   382\t            // 保存字幕数据\n   383\t            val subtitlesJson = gson.toJson(subtitleMemoryCache)\n   384\t            editor.putString(KEY_SUBTITLES, subtitlesJson)\n   385\t            \n   386\t            // 保存媒体映射\n   387\t            val mappingJson = gson.toJson(mediaMappingCache)\n   388\t            editor.putString(KEY_MEDIA_MAPPING, mappingJson)\n   389\t            \n   390\t            editor.apply()\n   391\t            \n   392\t        } catch (e: Exception) {\n   393\t            Log.e(TAG, \&quot;Error persisting cache to preferences\&quot;, e)\n   394\t        }\n   395\t    }\n   396\t    \n   397\t    private fun getCacheSize(): Long {\n   398\t        return try {\n   399\t            subtitleDir.listFiles()?.sumOf { it.length() } ?: 0L\n   400\t        } catch (e: Exception) {\n   401\t            0L\n   402\t        }\n   403\t    }\n   404\t    \n   405\t    private fun cleanOrphanedFiles() {\n   406\t        try {\n   407\t            val cachedPaths = subtitleMemoryCache.values\n   408\t                .mapNotNull { it.localPath.takeIf { path -&gt; path.isNotEmpty() } }\n   409\t                .toSet()\n   410\t            \n   411\t            subtitleDir.listFiles()?.forEach { file -&gt;\n   412\t                if (file.absolutePath !in cachedPaths) {\n   413\t                    if (file.delete()) {\n   414\t                        Log.d(TAG, \&quot;Deleted orphaned file: ${file.name}\&quot;)\n   415\t                    }\n   416\t                }\n   417\t            }\n   418\t        } catch (e: Exception) {\n   419\t            Log.w(TAG, \&quot;Error cleaning orphaned files: ${e.message}\&quot;)\n   420\t        }\n   421\t    }\n   422\t    \n   423\t    private fun checkAndCleanupIfNeeded() {\n   424\t        try {\n   425\t            val lastCleanup = preferences.getLong(KEY_LAST_CLEANUP, 0L)\n   426\t            val daysSinceCleanup = (System.currentTimeMillis() - lastCleanup) / (24 * 60 * 60 * 1000L)\n   427\t            \n   428\t            if (daysSinceCleanup &gt;= CLEANUP_INTERVAL_DAYS) {\n   429\t                // 异步执行清理，但不等待结果以避免suspend函数调用错误\n   430\t                kotlinx.coroutines.GlobalScope.launch {\n   431\t                    try {\n   432\t                        cleanExpiredSubtitles()\n   433\t                        cleanupToSize()\n   434\t                    } catch (e: Exception) {\n   435\t                        Log.w(TAG, \&quot;Error during background cleanup: ${e.message}\&quot;)\n   436\t                    }\n   437\t                }\n   438\t            }\n   439\t        } catch (e: Exception) {\n   440\t            Log.w(TAG, \&quot;Error checking cleanup: ${e.message}\&quot;)\n   441\t        }\n   442\t    }\n   443\t}\n   444\t\n   445\t/**\n   446\t * 缓存统计信息\n   447\t */\n   448\tdata class CacheStats(\n   449\t    val totalSubtitles: Int = 0,\n   450\t    val downloadedSubtitles: Int = 0,\n   451\t    val cacheSize: Long = 0L,\n   452\t    val lastCleanup: Long = 0L\n   453\t) {\n   454\t    val cacheSizeMB: Float\n   455\t        get() = cacheSize / (1024f * 1024f)\n   456\t        \n   457\t    val daysSinceCleanup: Long\n   458\t        get() = if (lastCleanup &gt; 0) {\n   459\t            (System.currentTimeMillis() - lastCleanup) / (24 * 60 * 60 * 1000L)\n   460\t        } else {\n   461\t            -1L\n   462\t        }\n   463\t}\nTotal lines in file: 463\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;36a183d7-5d28-405d-9c83-f536175a7a4a;toolu_vrtx_01SDHvcjHgyMiRnhZ1farxFU&quot;:{&quot;requestId&quot;:&quot;36a183d7-5d28-405d-9c83-f536175a7a4a&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01SDHvcjHgyMiRnhZ1farxFU&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;The following code sections were retrieved:\nPath: app/src/main/java/com/tvplayer/webdav/data/model/Subtitle.kt\n     1\tpackage com.tvplayer.webdav.data.model\n     2\t\n     3\timport android.os.Parcelable\n     4\timport kotlinx.parcelize.Parcelize\n     5\timport java.io.File\n     6\t\n     7\t/**\n     8\t * 字幕文件数据模型\n     9\t */\n    10\t@Parcelize\n    11\tdata class Subtitle(\n    12\t    val id: String = \&quot;\&quot;, // 字幕唯一标识\n    13\t    val title: String = \&quot;\&quot;, // 字幕标题\n    14\t    val language: String = \&quot;\&quot;, // 语言代码 (zh, en, zh-cn, en-us)\n    15\t    val languageName: String = \&quot;\&quot;, // 语言显示名称\n    16\t    val format: SubtitleFormat = SubtitleFormat.SRT, // 字幕格式\n    17\t    val encoding: String = \&quot;UTF-8\&quot;, // 字幕编码\n    18\t    val downloadUrl: String = \&quot;\&quot;, // 下载链接\n    19\t    val localPath: String = \&quot;\&quot;, // 本地文件路径\n    20\t    val fileSize: Long = 0L, // 文件大小（字节）\n    21\t    val hash: String = \&quot;\&quot;, // 文件哈希值\n    22\t    val source: SubtitleSource = SubtitleSource.UNKNOWN, // 字幕来源\n    23\t    val rating: Float = 0.0f, // 评分 (0.0-10.0)\n    24\t    val downloadCount: Int = 0, // 下载次数\n    25\t    val uploadDate: Long = 0L, // 上传时间戳\n    26\t    val uploader: String = \&quot;\&quot;, // 上传者\n    27\t    val isDownloaded: Boolean = false, // 是否已下载\n    28\t    val syncInfo: SubtitleSyncInfo? = null, // 同步信息\n    29\t    val metadata: Map&lt;String, String&gt; = emptyMap() // 额外元数据\n    30\t) : Parcelable {\n    31\t    \n    32\t    /**\n    33\t     * 获取本地字幕文件\n    34\t     */\n    35\t    fun getLocalFile(): File? {\n    36\t        return if (isDownloaded &amp;&amp; localPath.isNotEmpty()) {\n    37\t            File(localPath).takeIf { it.exists() }\n    38\t        } else null\n    39\t    }\n    40\t    \n    41\t    /**\n    42\t     * 检查字幕是否可用\n    43\t     */\n    44\t    fun isAvailable(): Boolean {\n    45\t        return isDownloaded &amp;&amp; getLocalFile() != null\n    46\t    }\n    47\t    \n    48\t    /**\n    49\t     * 获取字幕描述信息\n    50\t     */\n    51\t    fun getDescription(): String {\n    52\t        val parts = mutableListOf&lt;String&gt;()\n    53\t        if (languageName.isNotEmpty()) parts.add(languageName)\n    54\t        if (rating &gt; 0) parts.add(\&quot;评分: %.1f\&quot;.format(rating))\n    55\t        if (downloadCount &gt; 0) parts.add(\&quot;下载: $downloadCount\&quot;)\n    56\t        return parts.joinToString(\&quot; | \&quot;)\n    57\t    }\n    58\t    \n    59\t    /**\n    60\t     * 获取显示标题\n    61\t     */\n    62\t    fun getDisplayTitle(): String {\n    63\t        return if (title.isNotEmpty()) title else \&quot;字幕 - $languageName\&quot;\n    64\t    }\n    65\t}\n    66\t\n    67\t/**\n    68\t * 字幕格式枚举\n    69\t */\n    70\t@Parcelize\n    71\tenum class SubtitleFormat(val extension: String, val mimeType: String) : Parcelable {\n    72\t    SRT(\&quot;srt\&quot;, \&quot;application/x-subrip\&quot;),\n    73\t    ASS(\&quot;ass\&quot;, \&quot;text/x-ssa\&quot;),\n    74\t    SSA(\&quot;ssa\&quot;, \&quot;text/x-ssa\&quot;),\n    75\t    VTT(\&quot;vtt\&quot;, \&quot;text/vtt\&quot;),\n    76\t    SUB(\&quot;sub\&quot;, \&quot;text/x-subviewer\&quot;),\n    77\t    IDX(\&quot;idx\&quot;, \&quot;application/x-subtitle\&quot;),\n    78\t    SMI(\&quot;smi\&quot;, \&quot;application/x-sami\&quot;),\n    79\t    TXT(\&quot;txt\&quot;, \&quot;text/plain\&quot;);\n    80\t    \n    81\t    companion object {\n    82\t        fun fromExtension(extension: String): SubtitleFormat {\n    83\t            return values().find { \n    84\t                it.extension.equals(extension, ignoreCase = true) \n    85\t            } ?: SRT\n    86\t        }\n    87\t        \n    88\t        fun fromFileName(fileName: String): SubtitleFormat {\n    89\t            val ext = fileName.substringAfterLast('.', \&quot;\&quot;)\n    90\t            return fromExtension(ext)\n    91\t        }\n    92\t    }\n    93\t}\n    94\t\n    95\t/**\n    96\t * 字幕来源枚举\n    97\t */\n    98\t@Parcelize\n    99\tenum class SubtitleSource(val displayName: String, val baseUrl: String) : Parcelable {\n   100\t    OPENSUBTITLES(\&quot;OpenSubtitles\&quot;, \&quot;https://api.opensubtitles.com\&quot;),\n   101\t    SUBSCENE(\&quot;Subscene\&quot;, \&quot;https://subscene.com\&quot;),\n   102\t    YIFYSUBTITLES(\&quot;YifySubtitles\&quot;, \&quot;https://yifysubtitles.org\&quot;),\n   103\t    SUBDL(\&quot;SubDL\&quot;, \&quot;https://subdl.com\&quot;),\n   104\t    LOCAL(\&quot;本地字幕\&quot;, \&quot;\&quot;),\n   105\t    MANUAL(\&quot;手动导入\&quot;, \&quot;\&quot;),\n   106\t    UNKNOWN(\&quot;未知来源\&quot;, \&quot;\&quot;);\n   107\t    \n   108\t    val isOnline: Boolean\n   109\t        get() = baseUrl.isNotEmpty()\n   110\t}\n   111\t\n   112\t/**\n   113\t * 字幕同步信息\n   114\t */\n   115\t@Parcelize\n   116\tdata class SubtitleSyncInfo(\n   117\t    val offsetMs: Long = 0L, // 时间偏移（毫秒）\n   118\t    val speedRatio: Float = 1.0f, // 播放速度比例\n   119\t    val fps: Float = 0.0f, // 帧率\n   120\t    val isAutoSynced: Boolean = false, // 是否自动同步\n   121\t    val confidence: Float = 0.0f // 同步置信度 (0.0-1.0)\n   122\t) : Parcelable {\n   123\t    \n   124\t    /**\n   125\t     * 应用时间偏移\n   126\t     */\n   127\t    fun applyOffset(originalTimeMs: Long): Long {\n   128\t        return ((originalTimeMs * speedRatio) + offsetMs).toLong()\n   129\t    }\n   130\t}...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/SubtitleMatcher.kt\n...\n   577\t    \n   578\t    private data class FileNameInfo(\n   579\t        val title: String,\n   580\t        val year: Int,\n   581\t        val season: Int,\n   582\t        val episode: Int,\n   583\t        val resolution: String,\n   584\t        val releaseGroup: String\n   585\t    )\n   586\t}\n   587\t\n   588\t/**\n   589\t * 字幕匹配结果\n   590\t */\n   591\tdata class SubtitleMatch(\n   592\t    val subtitle: Subtitle,\n   593\t    val similarity: Float, // 相似度 (0.0-1.0)\n   594\t    val confidence: Float, // 置信度 (0.0-1.0)\n   595\t    val matchReasons: List&lt;MatchReason&gt; = emptyList()\n   596\t) {\n   597\t    val isExcellentMatch: Boolean\n   598\t        get() = similarity &gt;= 0.9f\n   599\t        \n   600\t    val isGoodMatch: Boolean\n   601\t        get() = similarity &gt;= 0.7f\n   602\t        \n   603\t    val qualityLevel: MatchQuality\n   604\t        get() = when {\n   605\t            similarity &gt;= 0.9f -&gt; MatchQuality.EXCELLENT\n   606\t            similarity &gt;= 0.7f -&gt; MatchQuality.GOOD\n   607\t            similarity &gt;= 0.5f -&gt; MatchQuality.FAIR\n   608\t            else -&gt; MatchQuality.POOR\n   609\t        }\n   610\t}\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/SubtitleSearchService.kt\n...\n    50\t\n    51\t/**\n    52\t * API限制信息\n    53\t */\n    54\tdata class ApiLimitInfo(\n    55\t    val requestsPerDay: Int = 200, // 每日请求限制\n    56\t    val requestsUsed: Int = 0, // 已使用请求数\n    57\t    val remainingRequests: Int = 200, // 剩余请求数\n    58\t    val resetTime: Long = 0L, // 重置时间戳\n    59\t    val isLimited: Boolean = false // 是否受限\n    60\t) {\n    61\t    val canMakeRequest: Boolean\n    62\t        get() = !isLimited &amp;&amp; remainingRequests &gt; 0\n    63\t}\n    64\t\n    65\t/**\n    66\t * 搜索结果\n    67\t */\n    68\tdata class SubtitleSearchResult(\n    69\t    val subtitles: List&lt;Subtitle&gt; = emptyList(),\n    70\t    val totalCount: Int = 0,\n    71\t    val searchTime: Long = 0L, // 搜索耗时（毫秒）\n    72\t    val source: SubtitleSource = SubtitleSource.UNKNOWN,\n    73\t    val errors: List&lt;String&gt; = emptyList()\n    74\t) {\n    75\t    val isSuccess: Boolean\n    76\t        get() = errors.isEmpty()\n    77\t        \n    78\t    val hasResults: Boolean\n    79\t        get() = subtitles.isNotEmpty()\n    80\t}...\nPath: app/src/main/java/com/tvplayer/webdav/data/model/SubtitleConfig.kt\n...\n     6\t\n     7\t/**\n     8\t * 字幕配置模型\n     9\t */\n    10\t@Parcelize\n    11\tdata class SubtitleConfig(\n    12\t    // 显示设置\n    13\t    val isEnabled: Boolean = true, // 是否启用字幕\n    14\t    val primaryLanguage: String = \&quot;zh\&quot;, // 首选语言\n    15\t    val fallbackLanguage: String = \&quot;en\&quot;, // 备用语言\n    16\t    val autoSelectLanguage: Boolean = true, // 自动选择语言\n    17\t    \n    18\t    // 样式设置\n    19\t    val textSize: Float = 16.0f, // 字体大小 (sp)\n    20\t    val textColor: Int = Color.WHITE, // 字体颜色\n    21\t    val backgroundColor: Int = Color.TRANSPARENT, // 背景颜色\n    22\t    val outlineColor: Int = Color.BLACK, // 描边颜色\n    23\t    val outlineWidth: Float = 1.0f, // 描边宽度\n    24\t    val shadowColor: Int = Color.BLACK, // 阴影颜色\n    25\t    val shadowRadius: Float = 1.0f, // 阴影半径\n    26\t    val shadowOffsetX: Float = 1.0f, // 阴影X偏移\n    27\t    val shadowOffsetY: Float = 1.0f, // 阴影Y偏移\n    28\t    \n    29\t    // 位置设置\n    30\t    val position: SubtitlePosition = SubtitlePosition.BOTTOM, // 字幕位置\n    31\t    val marginHorizontal: Float = 32.0f, // 水平边距 (dp)\n    32\t    val marginVertical: Float = 48.0f, // 垂直边距 (dp)\n    33\t    val alignment: SubtitleAlignment = SubtitleAlignment.CENTER, // 对齐方式\n    34\t    \n    35\t    // 字体设置\n    36\t    val fontFamily: String = \&quot;default\&quot;, // 字体族\n    37\t    val isBold: Boolean = false, // 是否粗体\n    38\t    val isItalic: Boolean = false, // 是否斜体\n    39\t    \n    40\t    // 同步设置\n    41\t    val globalOffsetMs: Long = 0L, // 全局时间偏移（毫秒）\n    42\t    val autoSync: Boolean = true, // 自动同步\n    43\t    val syncSensitivity: Float = 0.5f, // 同步敏感度 (0.0-1.0)\n    44\t    \n    45\t    // 下载设置\n    46\t    val autoDownload: Boolean = true, // 自动下载字幕\n    47\t    val downloadQuality: SubtitleQuality = SubtitleQuality.BEST, // 下载质量偏好\n    48\t    val maxCacheSize: Long = 100 * 1024 * 1024L, // 最大缓存大小 (100MB)\n    49\t    val cacheExpireDays: Int = 30, // 缓存过期天数\n    50\t    \n    51\t    // 搜索设置\n    52\t    val enabledSources: Set&lt;SubtitleSource&gt; = setOf(\n    53\t        SubtitleSource.OPENSUBTITLES,\n    54\t        SubtitleSource.SUBSCENE\n    55\t    ), // 启用的字幕源\n    56\t    val searchTimeout: Int = 10, // 搜索超时时间（秒）\n    57\t    val maxResults: Int = 20, // 最大搜索结果数\n    58\t    \n    59\t    // 高级设置\n    60\t    val encoding: String = \&quot;UTF-8\&quot;, // 默认编码\n    61\t    val lineSpacing: Float = 1.2f, // 行间距\n    62\t    val maxLines: Int = 3, // 最大行数\n    63\t    val wordWrap: Boolean = true, // 自动换行\n    64\t    val fadeInDuration: Long = 200L, // 淡入时长（毫秒）\n    65\t    val fadeOutDuration: Long = 200L // 淡出时长（毫秒）\n    66\t) : Parcelable {\n    67\t    \n    68\t    companion object {\n    69\t        /**\n    70\t         * 获取默认配置\n    71\t         */\n    72\t        fun getDefault(): SubtitleConfig = SubtitleConfig()\n    73\t        \n    74\t        /**\n    75\t         * 获取简体中文优化配置\n    76\t         */\n    77\t        fun getChineseOptimized(): SubtitleConfig = SubtitleConfig(\n    78\t            primaryLanguage = \&quot;zh-cn\&quot;,\n    79\t            fallbackLanguage = \&quot;zh\&quot;,\n    80\t            textSize = 18.0f,\n    81\t            outlineWidth = 1.5f,\n    82\t            marginVertical = 60.0f\n    83\t        )\n    84\t        \n    85\t        /**\n    86\t         * 获取英文优化配置\n    87\t         */\n    88\t        fun getEnglishOptimized(): SubtitleConfig = SubtitleConfig(\n    89\t            primaryLanguage = \&quot;en\&quot;,\n    90\t            fallbackLanguage = \&quot;en-us\&quot;,\n    91\t            textSize = 16.0f,\n    92\t            fontFamily = \&quot;sans-serif\&quot;\n    93\t        )\n    94\t    }\n    95\t    \n    96\t    /**\n    97\t     * 检查配置是否有效\n    98\t     */\n    99\t    fun isValid(): Boolean {\n   100\t        return textSize &gt; 0 &amp;&amp; \n   101\t               marginHorizontal &gt;= 0 &amp;&amp; \n   102\t               marginVertical &gt;= 0 &amp;&amp;\n   103\t               outlineWidth &gt;= 0 &amp;&amp;\n   104\t               maxCacheSize &gt; 0 &amp;&amp;\n   105\t               searchTimeout &gt; 0 &amp;&amp;\n   106\t               maxResults &gt; 0\n   107\t    }\n   108\t    \n   109\t    /**\n   110\t     * 应用全局时间偏移\n   111\t     */\n   112\t    fun applyGlobalOffset(timeMs: Long): Long {\n   113\t        return timeMs + globalOffsetMs\n   114\t    }\n   115\t}\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/subtitle/OpenSubtitlesService.kt\n...\n   343\t        \n   344\t        return Subtitle(\n   345\t            id = id,\n   346\t            title = attributes.optString(\&quot;release\&quot;, \&quot;\&quot;),\n   347\t            language = language,\n   348\t            languageName = getLanguageDisplayName(language),\n   349\t            format = SubtitleFormat.SRT, // OpenSubtitles主要提供SRT\n   350\t            downloadUrl = file?.optString(\&quot;link\&quot;, \&quot;\&quot;) ?: \&quot;\&quot;,\n   351\t            fileSize = file?.optLong(\&quot;file_size\&quot;, 0L) ?: 0L,\n   352\t            source = SubtitleSource.OPENSUBTITLES,\n   353\t            rating = attributes.optDouble(\&quot;ratings\&quot;, 0.0).toFloat(),\n   354\t            downloadCount = attributes.optInt(\&quot;download_count\&quot;, 0),\n   355\t            uploadDate = parseUploadDate(attributes.optString(\&quot;upload_date\&quot;, \&quot;\&quot;)),\n   356\t            uploader = attributes.optString(\&quot;uploader\&quot;, \&quot;\&quot;),\n   357\t            metadata = mapOf(\n   358\t                \&quot;release\&quot; to attributes.optString(\&quot;release\&quot;, \&quot;\&quot;),\n   359\t                \&quot;comments\&quot; to attributes.optString(\&quot;comments\&quot;, \&quot;\&quot;),\n   360\t                \&quot;hearing_impaired\&quot; to attributes.optBoolean(\&quot;hearing_impaired\&quot;, false).toString()\n   361\t            )\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/subtitle/SubtitleManagerTest.kt\n...\n   200\t    \n   201\t    private fun createTestSubtitle(\n   202\t        id: String,\n   203\t        title: String,\n   204\t        language: String,\n   205\t        rating: Float = 0.0f,\n   206\t        downloadCount: Int = 100,\n   207\t        isDownloaded: Boolean = false\n   208\t    ): Subtitle {\n   209\t        return Subtitle(\n   210\t            id = id,\n   211\t            title = title,\n   212\t            language = language,\n   213\t            languageName = when (language) {\n   214\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   215\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   216\t                \\\&quot;ja\\\&quot; -&gt; \\\&quot;日本語\\\&quot;\n   217\t                else -&gt; language.uppercase()\n   218\t            },\n   219\t            format = SubtitleFormat.SRT,\n   220\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   221\t            localPath = if (isDownloaded) \\\&quot;/test/cache/subtitle_$id.srt\\\&quot; else \\\&quot;\\\&quot;,\n   222\t            fileSize = 1024L * 50, // 50KB\n   223\t            source = SubtitleSource.OPENSUBTITLES,\n   224\t            rating = rating,\n   225\t            downloadCount = downloadCount,\n   226\t            uploadDate = System.currentTimeMillis() - 86400000L, // 1天前\n   227\t            uploader = \\\&quot;test_user\\\&quot;,\n   228\t            isDownloaded = isDownloaded\n   229\t        )\n   230\t    }\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/storage/SubtitleCacheTest.kt\n...\n   255\t    \n   256\t    // 辅助方法\n   257\t    \n   258\t    private fun createTestSubtitle(\n   259\t        id: String,\n   260\t        title: String,\n   261\t        language: String,\n   262\t        rating: Float = 0.0f,\n   263\t        downloadCount: Int = 100,\n   264\t        isDownloaded: Boolean = true,\n   265\t        uploadDate: Long = System.currentTimeMillis()\n   266\t    ): Subtitle {\n   267\t        return Subtitle(\n   268\t            id = id,\n   269\t            title = title,\n   270\t            language = language,\n   271\t            languageName = when (language) {\n   272\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   273\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   274\t                \\\&quot;ja\\\&quot; -&gt; \\\&quot;日本語\\\&quot;\n   275\t                else -&gt; language.uppercase()\n   276\t            },\n   277\t            format = SubtitleFormat.SRT,\n   278\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   279\t            localPath = if (isDownloaded) \\\&quot;/test/cache/subtitle_$id.srt\\\&quot; else \\\&quot;\\\&quot;,\n   280\t            fileSize = 1024L * 50,\n   281\t            source = SubtitleSource.OPENSUBTITLES,\n   282\t            rating = rating,\n   283\t            downloadCount = downloadCount,\n   284\t            uploadDate = uploadDate,\n   285\t            uploader = \\\&quot;test_user\\\&quot;,\n   286\t            isDownloaded = isDownloaded\n   287\t        )\n   288\t    }\n...\nPath: app/src/test/java/com/tvplayer/webdav/data/subtitle/SubtitleMatcherTest.kt\n...\n   246\t    \n   247\t    private fun createTestSubtitle(\n   248\t        id: String,\n   249\t        title: String,\n   250\t        language: String,\n   251\t        rating: Float = 0.0f,\n   252\t        downloadCount: Int = 100,\n   253\t        season: Int? = null,\n   254\t        episode: Int? = null,\n   255\t        year: Int? = null\n   256\t    ): Subtitle {\n   257\t        val metadata = mutableMapOf&lt;String, String&gt;()\n   258\t        season?.let { metadata[\\\&quot;season_number\\\&quot;] = it.toString() }\n   259\t        episode?.let { metadata[\\\&quot;episode_number\\\&quot;] = it.toString() }\n   260\t        year?.let { metadata[\\\&quot;year\\\&quot;] = it.toString() }\n   261\t        \n   262\t        return Subtitle(\n   263\t            id = id,\n   264\t            title = title,\n   265\t            language = language,\n   266\t            languageName = when (language) {\n   267\t                \\\&quot;zh-cn\\\&quot; -&gt; \\\&quot;简体中文\\\&quot;\n   268\t                \\\&quot;en\\\&quot; -&gt; \\\&quot;English\\\&quot;\n   269\t                \\\&quot;ko\\\&quot; -&gt; \\\&quot;한국어\\\&quot;\n   270\t                else -&gt; language.uppercase()\n   271\t            },\n   272\t            format = SubtitleFormat.SRT,\n   273\t            downloadUrl = \\\&quot;https://example.com/subtitle_$id.srt\\\&quot;,\n   274\t            localPath = \\\&quot;/test/cache/subtitle_$id.srt\\\&quot;,\n   275\t            fileSize = 1024L * 50,\n   276\t            source = SubtitleSource.OPENSUBTITLES,\n   277\t            rating = rating,\n   278\t            downloadCount = downloadCount,\n   279\t            uploadDate = System.currentTimeMillis() - 86400000L,\n   280\t            uploader = \\\&quot;test_user\\\&quot;,\n   281\t            isDownloaded = true,\n   282\t            metadata = metadata\n   283\t        )\n   284\t    }\n   285\t}\&quot;, \&quot;original_text\&quot;: \&quot;\&quot;, \&quot;replace_all\&quot;: false}]...\nPath: app/src/main/java/com/tvplayer/webdav/data/model/SubtitleSearchRequest.kt\n...\n    32\t    \n    33\t    // 搜索参数\n    34\t    val languages: List&lt;String&gt; = listOf(\&quot;zh\&quot;, \&quot;en\&quot;), // 搜索语言列表\n    35\t    val sources: Set&lt;SubtitleSource&gt; = setOf(SubtitleSource.OPENSUBTITLES), // 搜索源\n    36\t    val maxResults: Int = 20, // 最大结果数\n    37\t    val timeoutSeconds: Int = 10, // 超时时间\n    38\t    val minRating: Float = 0.0f, // 最小评分过滤\n    39\t    val onlyHD: Boolean = false, // 仅搜索高清字幕\n    40\t    \n    41\t    // 高级选项\n    42\t    val fuzzyMatch: Boolean = true, // 模糊匹配\n    43\t    val includeHearingImpaired: Boolean = false, // 包含听力障碍字幕\n    44\t    val excludeMachineTranslated: Boolean = true, // 排除机器翻译\n    45\t    val preferredFormats: List&lt;SubtitleFormat&gt; = listOf(SubtitleFormat.SRT, SubtitleFormat.ASS) // 偏好格式\n    46\t) : Parcelable {\n    47\t    \n    48\t    /**\n    49\t     * 从MediaItem创建搜索请求\n    50\t     */\n    51\t    companion object {\n    52\t        fun fromMediaItem(mediaItem: MediaItem, config: SubtitleConfig): SubtitleSearchRequest {\n    53\t            return SubtitleSearchRequest(\n    54\t                mediaType = mediaItem.mediaType,\n    55\t                title = mediaItem.title,\n    56\t                originalTitle = mediaItem.originalTitle ?: \&quot;\&quot;,\n    57\t                year = extractYearFromDate(mediaItem.releaseDate),\n    58\t                imdbId = \&quot;\&quot;, // MediaItem中暂无此属性\n    59\t                tmdbId = 0, // MediaItem中暂无此属性\n    60\t                seasonNumber = mediaItem.seasonNumber ?: 0,\n    61\t                episodeNumber = mediaItem.episodeNumber ?: 0,\n    62\t                fileName = extractFileNameFromPath(mediaItem.filePath),\n    63\t                fileSize = mediaItem.fileSize,\n    64\t                duration = mediaItem.duration * 1000, // 转换为毫秒\n    65\t                languages = listOf(config.primaryLanguage, config.fallbackLanguage).distinct(),\n    66\t                sources = config.enabledSources,\n    67\t                maxResults = config.maxResults,\n...\nPath: app/src/main/java/com/tvplayer/webdav/data/storage/SubtitleCache.kt\n...\n    60\t    \n    61\t    /**\n    62\t     * 保存字幕到缓存\n    63\t     * @param subtitle 字幕信息\n    64\t     * @param mediaId 关联的媒体ID（可选）\n    65\t     */\n    66\t    suspend fun saveSubtitle(subtitle: Subtitle, mediaId: String? = null) {\n    67\t        withContext(Dispatchers.IO) {\n    68\t            cacheMutex.withLock {\n    69\t                try {\n    70\t                    // 保存到内存缓存\n    71\t                    subtitleMemoryCache[subtitle.id] = subtitle\n    72\t                    \n    73\t                    // 如果有关联媒体，建立映射关系\n    74\t                    mediaId?.let { id -&gt;\n    75\t                        val subtitleIds = mediaMappingCache.getOrPut(id) { mutableSetOf() }\n    76\t                        subtitleIds.add(subtitle.id)\n    77\t                    }\n    78\t                    \n    79\t                    // 持久化到SharedPreferences\n    80\t                    persistCacheToPreferences()\n    81\t                    \n    82\t                    Log.d(TAG, \&quot;Subtitle cached: ${subtitle.id} for media: $mediaId\&quot;)\n    83\t                    \n    84\t                } catch (e: Exception) {\n    85\t                    Log.e(TAG, \&quot;Er...&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;4a53ac06-4696-42e8-aa07-db2c73e3cc41;toolu_vrtx_01PK6WyMNPrM4j5VYRPk3sKh&quot;:{&quot;requestId&quot;:&quot;4a53ac06-4696-42e8-aa07-db2c73e3cc41&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01PK6WyMNPrM4j5VYRPk3sKh&quot;,&quot;phase&quot;:4}},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:true,&quot;extraData&quot;:{&quot;isAgentConversation&quot;:true,&quot;hasAgentOnboarded&quot;:true,&quot;hasDirtyEdits&quot;:false},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;014c463a-b1fe-41eb-8a85-7f733c4f52ed&quot;}},&quot;agentExecutionMode&quot;:&quot;manual&quot;,&quot;isPanelCollapsed&quot;:true,&quot;displayedAnnouncements&quot;:[]}" />
      </map>
    </option>
  </component>
</project>